expect_equal(
test@phases$phase2@waves$wave1@sampled_data,
mwget(test, phase = 2, wave = 1, slot = "sampled_data")
)
# and that writing them with mwget worked
expect_equal(
test@phases$phase2@waves$wave1@design,
data.frame(
strata = unique(iris$Species),
n_to_sample = c(5, 5, 5)
)
)
expect_equal(
test@phases$phase2@waves$wave1@sampled_data,
dplyr::select(iris, id, Sepal.Width)[samples, ]
)
expect_equal(
test@phases$phase1$data,
dplyr::select(iris, -Sepal.Width)
)
test_that("errors work when invalid slot is accessed", {
expect_error(
mwget(MySurvey, phase = NA, slot = "data"),
"must specify a phase unless getting overall metadata"
)
expect_error(
mwget(MySurvey, phase = 2, wave = NA, slot = "data"),
"must specify wave number unless"
)
expect_error(
mwget(MySurvey, phase = NA, slot = "data") <-
data.frame(),
"must specify a phase unless getting overall metadata"
)
expect_error(
mwget(MySurvey, phase = 2, wave = NA, slot = "data") <-
data.frame(),
"must specify wave number unless"
)
})
expect_error(
mwget(MySurvey, phase = NA, slot = "data"),
"must specify a phase unless getting overall metadata"
)
expect_error(
mwget(MySurvey, phase = 2, wave = NA, slot = "data"),
"must specify wave number unless"
)
expect_error(
mwget(MySurvey, phase = NA, slot = "data") <-
data.frame(),
"must specify a phase unless getting overall metadata"
)
expect_error(
mwset(MySurvey, phase = NA, slot = "data") <-
data.frame(),
"must specify a phase unless getting overall metadata"
)
expect_error(
mwset(MySurvey, phase = 2, wave = NA, slot = "data") <-
data.frame(),
"must specify wave number unless"
)
devtools::test()
install.packages("shinytest")
library(shinytest)
install.packages("shinytest")
install.packages("shinytest")
# Make multiwave object and add things into slots
MySurvey <- multiwave(phases = 2, waves = c(1, 3))
# To write overall metadata
mwset(MySurvey, slot = "metadata") <-
list(title = "Maternal Weight Survey")
test_that("metadata access works", {
# overall metadata
expect_equal(
get_data(MySurvey, phase = NA, slot = "metadata"),
MySurvey@metadata
)
# To access Phase 1 metadata
mwset(MySurvey, phase = 1, slot = "metadata") <-
list(title = "Maternal Weight Survey Phase 1")
expect_equal(
get_data(MySurvey, phase = 1, slot = "metadata"),
MySurvey@phases$phase1$metadata
)
# To access Phase 2 metadata
mwset(MySurvey, phase = 2, slot = "metadata") <-
list(title = "Maternal Weight Survey Phase 2")
expect_equal(
get_data(MySurvey, phase = 2, slot = "metadata"),
MySurvey@phases$phase2@metadata
)
# To access Phase 2, Wave 1 metadata
mwset(MySurvey, phase = 1, wave = 1, slot = "metadata") <-
list(title = "Maternal Weight Survey Phase 2, Wave 1")
expect_equal(
get_data(MySurvey, phase = 2, wave = 1, slot = "metadata"),
MySurvey@phases$phase2@waves$wave1@metadata
)
})
devtools::load_all()
devtools::test()
install.packages("shinytest")
install.packages("shinytest")
library(DT)
install.packages("DT")
library(DT)
optimall_shiny()
?skip_on_os
knitr::opts_chunk$set(
collapse = TRUE,
comment = "#>"
)
library(optimall)
library(DiagrammeR)
library(survey)
library(datasets)
library(dplyr)
data(MatWgt_Sim, package = "optimall")
cp_design <- twophase(id = list(~id, ~id), strata = list(NULL, ~Species),
subset = ~as.logical(sampled_phase2),
data = survey_data, probs = list(~NULL, pairwise_probs))
#####
## Generate data
#####
set.seed(123)
n <- c(rmultinom(1, 996, c(1/3, 1/3, 1/3)))
col1 <- c(rep("setosa", times = n[1]),
rep("versicolor", times = n[2]),
rep("virginica", times = n[3]))
sl <- c(rnorm(n[1], 5.006, 0.124),
rnorm(n[2], 5.936, 0.266),
rnorm(n[3], 6.588, 0.404))
pl <- c(rnorm(n[1], 1.462, 0.173),
rnorm(n[2], 4.260, 0.470),
rnorm(n[3], 5.552, 0.552))
full_data <- data.frame("id" = 1:996,
"Species" = as.factor(col1),
"Sepal.Length" = sl,
"Petal.Length" = pl)
phase1_data <- full_data[,-4]
####
## Multiwave object setup
####
Survey <- multiwave(phases = 2, waves = c(1, 3),
phase1 = phase1_data)
set_mw(Survey, phase = 2, slot = "metadata") <- list(id = "id",
strata = "Species",
design_strata = "strata",
include_probs = TRUE)
####
## Wave 1
####
### Allocation: X-allocate with Phase 1 sepal length
Survey <- apply_multiwave(Survey, phase = 2, wave = 1,
fun = "optimum_allocation",
y = "Sepal.Length",
nsample = 50, method = "Neyman")
# get_mw(Survey, phase = 2, wave = 1, slot ="design")
### Select samples
Survey <- apply_multiwave(Survey, phase = 2, wave = 1,
fun = "sample_strata",
n_allocated = "stratum_size",
probs = ~stratum_size/npop)
### "Collect" data
set_mw(Survey, phase = 2, wave = 1, slot = "sampled_data") <-
full_data[full_data$id %in% get_mw(Survey, phase = 2, wave = 1,
slot = "samples")$ids,
c("id", "Petal.Length")]
Survey <- merge_samples(Survey, phase = 2, wave = 1)
####
## Wave 2
####
### Allocation: Neyman allocation with already-collected phase 2 data.
Survey <- apply_multiwave(Survey, phase = 2, wave = 2,
fun = "allocate_wave",
y = "Petal.Length",
nsample = 50, allocation_method = "Neyman",
already_sampled = "sampled_phase2")
# get_mw(phase = 2, wave = 2, slot = "design")
### Select samples
Survey <- apply_multiwave(Survey, phase = 2, wave = 2,
fun = "sample_strata",
n_allocated = "n_to_sample",
probs = ~n_to_sample/(npop - nsample_prior),
already_sampled = "sampled_phase2")
### "Collect" data
set_mw(Survey, phase = 2, wave = 2, slot = "sampled_data") <-
full_data[full_data$id %in% get_mw(Survey, phase = 2, wave = 2,
slot = "samples")$ids,
c("id", "Petal.Length")]
Survey <- merge_samples(Survey, phase = 2, wave = 2)
####
## Wave 3
####
### Allocation: Neyman allocation with already-collected phase 2 data.
Survey <- apply_multiwave(Survey, phase = 2, wave = 3,
fun = "allocate_wave",
y = "Petal.Length",
nsample = 50, allocation_method = "Neyman",
already_sampled = "sampled_phase2")
# get_mw(phase = 2, wave = 3, slot = "design")
### Select samples
Survey <- apply_multiwave(Survey, phase = 2, wave = 3,
fun = "sample_strata",
n_allocated = "n_to_sample",
probs = ~n_to_sample/(npop - nsample_prior),
already_sampled = "sampled_phase2")
### "Collect" data
set_mw(Survey, phase = 2, wave = 3, slot = "sampled_data") <-
full_data[full_data$id %in% get_mw(Survey, phase = 2, wave = 3,
slot = "samples")$ids,
c("id", "Petal.Length")]
Survey <- merge_samples(Survey, phase = 2, wave = 3)
### Final dataset for analysis
survey_data <- get_mw(Survey, phase = 2, wave = 3, slot = "data")
### Clean up for printing
survey_data <- survey_data[,c("id", "Species", "Sepal.Length",
"Petal.Length", "sampled_phase2",
"sampled_wave2.1", "sampled_wave2.2",
"sampled_wave2.3", "sampling_prob")]
survey_data <- survey_data[order(-survey_data$sampled_phase2,
survey_data$id), , drop = FALSE]
design <- twophase(id = list(~id, ~id), strata = list(NULL, ~Species),
subset = ~as.logical(sampled_phase2),
data = survey_data, method = "simple")
pst_design <- calibrate(design, phase = 2, formula = ~Species)
pst_est <- svymean(~Petal.Length, design = pst_design)
pst_est
pst_design_rake <- calibrate(pst_design, ~Sepal.Length,
phase = 2, calfun = "raking")
pst_est_rake <- svymean(~Petal.Length, design = pst_design_rake)
pst_est_rake
### Only need pairwise probs for elements sampled in phase 2
phase2_data <- survey_data[survey_data$sampled_phase2 == 1,]
phase2_data <- dplyr::mutate(phase2_data,
phase2_wave = case_when(sampled_wave2.1 == 1 ~ 1,
sampled_wave2.2 == 1 ~ 2,
sampled_wave2.3 == 1 ~ 3))
### Combine wave-specific designs
designW123 <- dplyr::bind_rows(cbind(phase2_wave = 1,
get_mw(Survey, 2, 1, "design")),
cbind(phase2_wave = 2,
get_mw(Survey, 2, 2, "design")),
cbind(phase2_wave = 3,
get_mw(Survey, 2, 3, "design")))
### Merge any differing column names, compute dependent probability as n_k/N_k*
### n_k/(N_k-1), merge with phase2_data
designW123 <- designW123 |>
dplyr::mutate(n_to_sample = dplyr::coalesce(n_to_sample, stratum_size),
nsample_prior = ifelse(is.na(nsample_prior),
0 , nsample_prior),
dependent_prob = n_to_sample/(npop - nsample_prior)*
n_to_sample/(npop - nsample_prior - 1)) #n/N*n/(N-1)
phase2_data <- phase2_data |>
dplyr::left_join(designW123, by = c("Species" = "strata", "phase2_wave"))
### Create pairwise probability matrix.
### For independent obs, just take product. Otherwise take dependent prob
independent_probs <- with(phase2_data, outer(sampling_prob, sampling_prob, "*"))
dependent_probs <- with(phase2_data,
outer(sqrt(dependent_prob),
sqrt(dependent_prob), "*"))
# Logical matrix of whether each pair is independent or dependent,
is_dependent <- with(phase2_data, outer(Species, Species, "==")) &
with(phase2_data, outer(phase2_wave, phase2_wave, "=="))
# Final matrix keeps dependent or independent
pairwise_probs <- ifelse(is_dependent, dependent_probs, independent_probs)
# Replace diag with element sampling probs
diag(pairwise_probs) <- phase2_data$sampling_prob
cp_design <- twophase(id = list(~id, ~id), strata = list(NULL, ~Species),
subset = ~as.logical(sampled_phase2),
data = survey_data, probs = list(~NULL, pairwise_probs))
cp_est <- svymean(~Petal.Length, design = pst_design)
cp_est
cp_est <- svymean(~Petal.Length, design = cp_design)
cp_est
?twophase
?poisson_sampling
?estWeights
packageVersion(survet)
packageVersion(survey)
packageVersion("survey")
install.packages("survey")
install.packages("survey")
library(survey)
packageVersion("survey")
library(optimall)
library(DiagrammeR)
library(survey)
library(datasets)
library(dplyr)
data(MatWgt_Sim, package = "optimall")
#####
## Generate data
#####
set.seed(123)
n <- c(rmultinom(1, 996, c(1/3, 1/3, 1/3)))
col1 <- c(rep("setosa", times = n[1]),
rep("versicolor", times = n[2]),
rep("virginica", times = n[3]))
sl <- c(rnorm(n[1], 5.006, 0.124),
rnorm(n[2], 5.936, 0.266),
rnorm(n[3], 6.588, 0.404))
pl <- c(rnorm(n[1], 1.462, 0.173),
rnorm(n[2], 4.260, 0.470),
rnorm(n[3], 5.552, 0.552))
full_data <- data.frame("id" = 1:996,
"Species" = as.factor(col1),
"Sepal.Length" = sl,
"Petal.Length" = pl)
phase1_data <- full_data[,-4]
####
## Multiwave object setup
####
Survey <- multiwave(phases = 2, waves = c(1, 3),
phase1 = phase1_data)
set_mw(Survey, phase = 2, slot = "metadata") <- list(id = "id",
strata = "Species",
design_strata = "strata",
include_probs = TRUE)
####
## Wave 1
####
### Allocation: X-allocate with Phase 1 sepal length
Survey <- apply_multiwave(Survey, phase = 2, wave = 1,
fun = "optimum_allocation",
y = "Sepal.Length",
nsample = 50, method = "Neyman")
# get_mw(Survey, phase = 2, wave = 1, slot ="design")
### Select samples
Survey <- apply_multiwave(Survey, phase = 2, wave = 1,
fun = "sample_strata",
n_allocated = "stratum_size",
probs = ~stratum_size/npop)
### "Collect" data
set_mw(Survey, phase = 2, wave = 1, slot = "sampled_data") <-
full_data[full_data$id %in% get_mw(Survey, phase = 2, wave = 1,
slot = "samples")$ids,
c("id", "Petal.Length")]
Survey <- merge_samples(Survey, phase = 2, wave = 1)
####
## Wave 2
####
### Allocation: Neyman allocation with already-collected phase 2 data.
Survey <- apply_multiwave(Survey, phase = 2, wave = 2,
fun = "allocate_wave",
y = "Petal.Length",
nsample = 50, allocation_method = "Neyman",
already_sampled = "sampled_phase2")
# get_mw(phase = 2, wave = 2, slot = "design")
### Select samples
Survey <- apply_multiwave(Survey, phase = 2, wave = 2,
fun = "sample_strata",
n_allocated = "n_to_sample",
probs = ~n_to_sample/(npop - nsample_prior),
already_sampled = "sampled_phase2")
### "Collect" data
set_mw(Survey, phase = 2, wave = 2, slot = "sampled_data") <-
full_data[full_data$id %in% get_mw(Survey, phase = 2, wave = 2,
slot = "samples")$ids,
c("id", "Petal.Length")]
Survey <- merge_samples(Survey, phase = 2, wave = 2)
####
## Wave 3
####
### Allocation: Neyman allocation with already-collected phase 2 data.
Survey <- apply_multiwave(Survey, phase = 2, wave = 3,
fun = "allocate_wave",
y = "Petal.Length",
nsample = 50, allocation_method = "Neyman",
already_sampled = "sampled_phase2")
# get_mw(phase = 2, wave = 3, slot = "design")
### Select samples
Survey <- apply_multiwave(Survey, phase = 2, wave = 3,
fun = "sample_strata",
n_allocated = "n_to_sample",
probs = ~n_to_sample/(npop - nsample_prior),
already_sampled = "sampled_phase2")
### "Collect" data
set_mw(Survey, phase = 2, wave = 3, slot = "sampled_data") <-
full_data[full_data$id %in% get_mw(Survey, phase = 2, wave = 3,
slot = "samples")$ids,
c("id", "Petal.Length")]
Survey <- merge_samples(Survey, phase = 2, wave = 3)
### Final dataset for analysis
survey_data <- get_mw(Survey, phase = 2, wave = 3, slot = "data")
### Clean up for printing
survey_data <- survey_data[,c("id", "Species", "Sepal.Length",
"Petal.Length", "sampled_phase2",
"sampled_wave2.1", "sampled_wave2.2",
"sampled_wave2.3", "sampling_prob")]
survey_data <- survey_data[order(-survey_data$sampled_phase2,
survey_data$id), , drop = FALSE]
head(survey_data)
design <- twophase(id = list(~id, ~id), strata = list(NULL, ~Species),
subset = ~as.logical(sampled_phase2),
data = survey_data, method = "simple")
pst_design <- calibrate(design, phase = 2, formula = ~Species)
pst_est <- svymean(~Petal.Length, design = pst_design)
pst_est
pst_design_rake <- calibrate(pst_design, ~Sepal.Length,
phase = 2, calfun = "raking")
pst_est_rake <- svymean(~Petal.Length, design = pst_design_rake)
pst_est_rake
### Only need pairwise probs for elements sampled in phase 2
phase2_data <- survey_data[survey_data$sampled_phase2 == 1,]
phase2_data <- dplyr::mutate(phase2_data,
phase2_wave = case_when(sampled_wave2.1 == 1 ~ 1,
sampled_wave2.2 == 1 ~ 2,
sampled_wave2.3 == 1 ~ 3))
### Combine wave-specific designs
designW123 <- dplyr::bind_rows(cbind(phase2_wave = 1,
get_mw(Survey, 2, 1, "design")),
cbind(phase2_wave = 2,
get_mw(Survey, 2, 2, "design")),
cbind(phase2_wave = 3,
get_mw(Survey, 2, 3, "design")))
### Merge any differing column names, compute dependent probability as n_k/N_k*
### n_k/(N_k-1), merge with phase2_data
designW123 <- designW123 |>
dplyr::mutate(n_to_sample = dplyr::coalesce(n_to_sample, stratum_size),
nsample_prior = ifelse(is.na(nsample_prior),
0 , nsample_prior),
dependent_prob = n_to_sample/(npop - nsample_prior)*
n_to_sample/(npop - nsample_prior - 1)) #n/N*n/(N-1)
phase2_data <- phase2_data |>
dplyr::left_join(designW123, by = c("Species" = "strata", "phase2_wave"))
### Create pairwise probability matrix.
### For independent obs, just take product. Otherwise take dependent prob
independent_probs <- with(phase2_data, outer(sampling_prob, sampling_prob, "*"))
dependent_probs <- with(phase2_data,
outer(sqrt(dependent_prob),
sqrt(dependent_prob), "*"))
# Logical matrix of whether each pair is independent or dependent,
is_dependent <- with(phase2_data, outer(Species, Species, "==")) &
with(phase2_data, outer(phase2_wave, phase2_wave, "=="))
# Final matrix keeps dependent or independent
pairwise_probs <- ifelse(is_dependent, dependent_probs, independent_probs)
# Replace diag with element sampling probs
diag(pairwise_probs) <- phase2_data$sampling_prob
cp_design <- twophase(id = list(~id, ~id), strata = list(NULL, ~Species),
subset = ~as.logical(sampled_phase2),
data = survey_data, probs = list(~NULL, pairwise_probs))
cp_est <- svymean(~Petal.Length, design = cp_design)
cp_est
?twophase
temp <- matrix(c(1,2,3,2,3,4,2,4,5), nrow =3 )
temp
eigen(temp)
x <- eigen(temp)
t(x)%*%x
?t
t(x)
?eigen
x$vectors <- eigen(temp)
t(x)%*%x
x
x <- eigen(temp)$vectors
t(x)%*%x
eigen(temp)$vectors
temp <- matrix(c(1,2,-3,2,3,-4,2,4,-5), nrow =3 )
x <- eigen(temp)$vectors
x
temp <- matrix(c(1,4,3,3,3,-4,2,4,-5), nrow =3 )
x <- eigen(temp)$vectors
x
temp <- matrix(c(8,4,3,-5,5,-2,7,9,-8), nrow =3 , byrow = TRUE)
x <- eigen(temp)$vectors
x
temp <- diag(c(2,3,4))*matrix(c(1,0,1,0,1,1,1,1,0), nrow = 3, byrow = TRUE)
temp
temp <- diag(c(2,3,4))*matrix(c(1,3,1,2,1,1,1,1,3), nrow = 3, byrow = TRUE)
temp
x <- eigen(temp)$vectors
t(x)%*%x
temp <- diag(c(2,3,4))*matrix(c(1,3,1,0,1,1,0,0,3), nrow = 3, byrow = TRUE)
temp
temp <- diag(c(2,3,4))%*%matrix(c(1,3,1,0,1,1,0,0,3), nrow = 3, byrow = TRUE)
temp
x <- eigen(temp)$vectors
x
x[,1]%*%x[,2]
x[,1]%*%t(x[,2])
t(x[,2])%*%x[,1]
t(x)%*%x
temp <- matrix(c(1,3,1,3,2,1,1,1,2), nrow = 3, byrow = TRUE)
temp
x <- eigen(temp)$vectors
x
t(x)%*%x
temp1 %*% diag(c(1,1,0,0)) %*% t(temp1)
temp1 <- matrix(c(1,2,2,4,
4,3,2,4,
5,6,4,3,
3,2,1,3), byrow = FALSE)
temp1 %*% diag(c(1,1,0,0)) %*% t(temp1)
temp1 <- matrix(c(1,2,2,4,
4,3,2,4,
5,6,4,3,
3,2,1,3), byrow = FALSE, nrow = 4)
temp1 %*% diag(c(1,1,0,0)) %*% t(temp1)
temp2 <- matrix(c(1,2,2,4,
4,3,2,4), byrow = FALSE, nrow = 4)
temp1
temp2
temp2 <- matrix(c(1,2,2,4,
4,3,2,4), byrow = FALSE, nrow = 4)
temp2 %*% temp2
temp2 %*% t(temp2)
temp1 %*% diag(c(1,1,0,0))
temp1 %*% diag(c(2,1,0,0))
