% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/apply_multiwave.R
\name{apply_multiwave}
\alias{apply_multiwave}
\title{Apply a basic optimall function to a Multiwave Object}
\usage{
apply_multiwave(x, phase, wave, fun, ...)
}
\arguments{
\item{x}{An Object of class \code{"multiwave"}}

\item{phase}{A numeric or character value specifying the phase of
\code{multiwave} where the desired output should be placed.}

\item{wave}{A numeric or character value specifying the wave of \code{phase}
in \code{multiwave} where the output should be placed.}

\item{fun}{A character value specifying the name of the \code{optimall} #' function to apply. The four functions are: \code{optimum_allocation}, \code{allocate_wave}, \code{sample_strata}, and \code{merge_samples}.
\itemize{
\item \code{optimum_allocation}: Uses the \code{data} from the previous wave (or previous phase if \code{wave = 1}) to determine the optimum sampling allocation for the specified wave. If used, the output multiwave object contains an updated \code{"design"} slot in the specified wave.
\item \code{allocate_wave}: Uses the \code{data} from the previous wave (or previous phase if \code{wave = 1}) to determine the optimum sampling allocation for the specified wave. If used, the output multiwave object contains an updated \code{"design"} slot in the specified wave.
\item \code{sample_strata}: Uses the \code{data} from the previous wave (or previous phase if \code{wave = 1}) and \code{design} from current wave to generate a vector of ids to sample for the current wave. If used, the output multiwave object contains an updated \code{"samples"} slot in the specified wave.
\item \code{merge_samples}: Uses the \code{data} from the previous wave (or
previous phase if \code{wave = 1}) and \code{sampled_data} from the
specified wave to generate the final, merged data for the current wave.
If used, the output multiwave object contains an updated \code{"data"}
slot in the specified wave. Note that \code{merge_samples} is already a
method for multiwave objects, so calling
it through \code{apply_optimall} is the exact same as calling it on its own.}
See documentation of these functions for more details on the specific uses and arguments.}

\item{...}{Optionally, arguments to be given to \code{function}. Not necessary if the arguments are already provided as named values in the wave, phase, or overall metadata in the multiwave object. Arguments provided here will override specifications in the metadata if provided in both places.}
}
\value{
The inputted multiwave object with one slot updated to include the
output of the specified function.

Note that the phase and wave arguments specify where the function
\emph{output} should be placed. \code{apply_multiwave} will determine where
to get the input dataframes from (returning an error if those slots are
empty or invalid) given the specified wave for the output. For example, if
\code{phase = 2, wave = 2, function = "allocate_wave"}, the data to
determine the optimum allocation will be taken from the previous wave
(phase 2, wave 1) and the output multiwave object will have an updated
\code{"design"} slot of phase 2, wave 2.
}
\description{
Given a specified phase and wave of an object of class multiwave,
\code{apply_multiwave} applies one of four \code{optimall} functions
and returns an updated multiwave object with the output of the applied
function in its specified slot.
}
