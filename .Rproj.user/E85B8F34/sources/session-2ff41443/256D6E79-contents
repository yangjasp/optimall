#######
### Multiwave sampling Estimation Comparisons
#######

## In this script I use the iris dataset (n=150) to conduct a simple
## simulation example of (three-wave) multiwave sampling.
## Over 1,000 iterations (randomness only comes from sampling, as the
## dataset itself is fixed), I conduct stratified sampling
## to sample from the 3 strata of species, with proportional allocation
## in Wave 1 and then use Neyman allocation in Waves 2 and 3. I then
## estimate the mean Sepal Width using 3 different strategies


######
### Load packages ------------------------------------------------------
#####
library(datasets)
library(dplyr)
library(optimall)
library(survey)
library(ReGenesees) # This is package the reviewer uses

#######
### Set parameters -------------------------------------------------
########
set.seed(02262023)
my_n_per_wave <- 18 # Number of samples per wave - total n will be 3 times this

#######
### Generate fake data
#######

my_n <- 996
col1 <- c(rep("setosa", times = my_n/3),
          rep("versicolor", times = my_n/3),
          rep("virginica", times = my_n/3))

sw <- c(rnorm(my_n/3, 3.428, 0.379),
        rnorm(my_n/3, 2.77, 0.314),
        rnorm(my_n/3, 2.974, 0.322))


data_sim <- data.frame("id" = 1:my_n,
                       "Species" = col1,
                       "strata" = as.factor(col1),
                       "Sepal.Width" = sw)


#######
### Function for one iteration --------------------------------------------
#######
run_sim_pstrat <- function(n_per_wave = 48){

  # Generate data
  my_n <- 996
  col1 <- c(rep("setosa", times = my_n/3),
            rep("versicolor", times = my_n/3),
            rep("virginica", times = my_n/3))

  sw <- c(rnorm(my_n/3, 3.428, 0.379),
          rnorm(my_n/3, 2.77, 0.314),
          rnorm(my_n/3, 2.974, 0.322))


  data_sim <- data.frame("id" = 1:my_n,
                         "Species" = col1,
                         "strata" = as.factor(col1),
                         "Sepal.Width" = sw)

  n <- n_per_wave

  ## Wave 1 allocation: proportional, 3 from each
  wave1_allocation <- data.frame(strata = c("setosa",
                                            "versicolor",
                                            "virginica"),
                                 n_to_sample = c(n/3,n/3,n/3))

  data_sim <- optimall::sample_strata(data = data_sim, strata = "strata",
                                      id = "id", design_data = wave1_allocation,
                                      design_strata = "strata",
                                      n_allocated = "n_to_sample")

  data_sim$sampled_wave1 <- data_sim$sample_indicator
  data_sim$Sepal.Width.obs <- ifelse(data_sim$sampled_wave1 == 1,
                                     data_sim$Sepal.Width, NA)

  ## Wave 2 allocation:
  wave2_allocation <- allocate_wave(data_sim,
                                    strata = "strata",
                                    y = "Sepal.Width.obs",
                                    already_sampled = "sampled_wave1", allocation_method = "Neyman",
                                    nsample = n, detailed = TRUE)

  data_sim <- optimall::sample_strata(data = data_sim, strata = "strata",
                                      id = "id", design_data = wave2_allocation,
                                      design_strata = "strata",
                                      already_sampled = "sampled_wave1",
                                      n_allocated = "n_to_sample")

  data_sim$sampled_wave2 <- data_sim$sample_indicator
  data_sim$already_sampled <- data_sim$sampled_wave1 + data_sim$sampled_wave2
  data_sim$Sepal.Width.obs <- ifelse(data_sim$already_sampled == 1,
                                     data_sim$Sepal.Width, NA)

  ## Wave 3
  wave3_allocation <- allocate_wave(data_sim,
                                    strata = "strata",
                                    y = "Sepal.Width.obs", allocation_method = "Neyman",
                                    already_sampled = "already_sampled",
                                    nsample = n, detailed = TRUE)

  data_sim <- optimall::sample_strata(data = data_sim, strata = "strata",
                                      id = "id", design_data = wave3_allocation,
                                      design_strata = "strata",
                                      already_sampled = "already_sampled",
                                      n_allocated = "n_to_sample")

  data_sim$sampled_wave3 <- data_sim$sample_indicator
  data_sim$already_sampled <- data_sim$sampled_wave1 + data_sim$sampled_wave2 +
    data_sim$sampled_wave3
  data_sim$Sepal.Width.obs <- ifelse(data_sim$already_sampled == 1,
                                     data_sim$Sepal.Width, NA)

  #####
  ## Estimation 1: Post-stratification
  #####

  mydesign <- twophase(id = list(~id, ~id), strata = list(NULL, ~strata),
                       subset = ~as.logical(already_sampled),
                       data = data_sim)
  est1 <- svymean(~Sepal.Width.obs, design = mydesign)
  confints1 <- confint(est1)

  #####
  ## Estimation 1.5: Post-stratification with wave as a stratifier - not working,
  ## as oversampling keeps happeningat least once in the simulations
  #####

  #data_sim <- data_sim %>%
  #  dplyr::mutate(wave_strata = case_when(
  #    sampled_wave1 == 1 ~ "A",
  #    sampled_wave2 == 1 ~ "B",
  #    TRUE ~ "C"),
  #    strata_test = interaction(strata, wave_strata))
  #mydesign <- twophase(id = list(~id, ~id), strata = list(NULL, ~strata_test),
  #                     subset = ~as.logical(already_sampled), data = data_sim)

  est2 <- svymean(~Sepal.Width.obs, design = mydesign)
  confints2 <- confint(est2)

  #####
  ## Estimation 2: Post-stratification with manual pairwise inclusion probs
  #####

  ###
  ### Here, I estimate the pairwise inclusion probabilities manually

  combined_allocation_df <- data.frame(strata = wave2_allocation$strata,
                                       npop = wave2_allocation$npop,
                                       wave1_size = wave1_allocation$n_to_sample,
                                       wave2_size = wave2_allocation$n_to_sample,
                                       wave3_size = wave3_allocation$n_to_sample)

  combined_allocation_df <- combined_allocation_df %>%
    dplyr::mutate(wave1_samp_prob = wave1_size/npop,
                  wave2_samp_prob = wave2_size/(npop-wave1_size) * (1-wave1_samp_prob),
                  #wave3_samp_prob = (wave3_size/(npop - wave1_size - wave2_size))*(1-wave1_samp_prob)*(1-wave2_samp_prob),
                  wave3_samp_prob = (wave3_size/(npop - wave1_size - wave2_size))*(1-wave1_size/npop - wave2_size/(npop-wave1_size) * (1-wave1_samp_prob)),
                  exact_prob = wave1_samp_prob + wave2_samp_prob + wave3_samp_prob,
                  naive_prob = (wave1_size + wave2_size + wave3_size)/npop,
                  myweight = 1/exact_prob,
                  myweight2 = exact_prob/naive_prob)

  data_sim <- data_sim %>%
    dplyr::left_join(dplyr::select(combined_allocation_df, strata,
                                   exact_prob, myweight),
                     by = "strata")
  temp <- data_sim %>%
      dplyr::mutate(weights = 1/exact_prob) %>%
      dplyr::filter(already_sampled == 1)

  ### Pairwise probs: Consider case
    # A. Different strata: Independent probs
    # B. Same stratum, different wave:

  wave1_ids <- temp[temp$sampled_wave1 == 1, "id"]
  wave2_ids <- temp[temp$sampled_wave2 == 1, "id"]
  wave3_ids <- temp[temp$sampled_wave3 == 1, "id"]

  prob_matrix <- diag(temp$exact_prob) # single value inclusion probs

  #for (i in 1:nrow(temp)){
  #  myid.i <- temp$id[i]
  #  mywave.i <- case_when(myid.i %in% wave1_ids ~ 1, myid.i %in% wave2_ids ~ 2,
  #                      myid.i %in% wave3_ids ~ 3)
  #  mystratum.i <- temp$strata[i]
  #  for(j in 1:nrow(temp)){
  #    if(i != j){
  #      myid.j <- temp$id[j]
  #      mywave.j <- case_when(myid.j %in% wave1_ids ~ 1, myid.j %in% wave2_ids ~ 2,
  #                            myid.j %in% wave3_ids ~ 3)
  #      mystratum.j <- temp$strata[j]
  #      if(mywave.i == mywave.j & mystratum.i = mystratum.j){
  #        pairwise_prob <-
  #      }
  #
  #    }
  #  }
  #}



  # Repeat with normal survey design, not twophase
  #temp <- data_sim %>%
  #  dplyr::mutate(weights = 1/exact_prob) %>%
  #  dplyr::filter(already_sampled == 1)
  #mydesign2_test <- svydesign(ids = ~id, strata = ~strata, weights = ~weights,
  #                            data = temp)

  #mydesign2_test <- svydesign(ids = ~id, strata = ~strata,
  #                            subset = ~ as.logical(already_sampled == 1),
  #                            data = data_sim)

  #est2_test <- svymean(~Sepal.Width.obs, design = mydesign2_test)
  #confints2_test <- confint(est2_test)

  #####
  ## Strategy 3: Add weights as reviewer proposed
  #####

  # Wave 1 weights
  wave1_data <- data_sim
  samp1 <- dplyr::filter(data_sim, sampled_wave1 == 1)
  wgt1 <- as.data.frame(table(wave1_data$strata) / table(wave1_data$strata[wave1_data$sampled_wave1==1]))
  colnames(wgt1) <- c("strata","weight")
  samp1 <- dplyr::left_join(samp1,wgt1, by = "strata")
  sum(samp1$weight)

  # Wave 2 weights
  wave2_data <- dplyr::filter(data_sim, sampled_wave1 == 0)
  samp2 <- dplyr::filter(data_sim, sampled_wave2 == 1)
  wgt2 <- as.data.frame(table(wave2_data$strata)/wave2_allocation$n_to_sample)
  colnames(wgt2) <- c("strata","weight")
  wgt2$weight <- ifelse(is.infinite(wgt2$weight), 0, wgt2$weight)
  samp2 <- dplyr::left_join(samp2,wgt2, by = "strata")
  sum(samp2$weight)

  # Wave 3 weights
  wave3_data <- dplyr::filter(data_sim, sampled_wave1 == 0 & sampled_wave2 == 0)
  samp3 <- dplyr::filter(data_sim, sampled_wave3 == 1)
  wgt3 <- as.data.frame(table(wave3_data$strata)/wave3_allocation$n_to_sample)
  colnames(wgt3) <- c("strata","weight")
  wgt3$weight <- ifelse(is.infinite(wgt3$weight), 0, wgt3$weight)
  samp3 <- dplyr::left_join(samp3,wgt3, by = "strata")
  sum(samp3$weight)

  # Normalization of weights: the sum of weights of the overall sample # must reproduce the total of units of first phase (10335), but the # contribution of each sample is made proportional to the different # subpopulations represented

  total <- sum(samp1$weight) + sum(samp2$weight) + sum(samp3$weight)
  samp1$weight_norm <- samp1$weight * (sum(nrow(data_sim)/sum(samp1$weight))) * sum(samp1$weight) /total
  sum(samp1$weight_norm)

  samp2$weight_norm <- samp2$weight * (sum(nrow(data_sim)/sum(samp2$weight))) * sum(samp2$weight) / total
  sum(samp2$weight_norm)

  samp3$weight_norm <- samp3$weight * (sum(nrow(data_sim)/sum(samp3$weight))) * sum(samp3$weight) / total
  sum(samp3$weight_norm)


  # Pooling: the pooled sample represent the whole first phase population
  samp <- rbind(samp1,samp2,samp3)
  sum(samp$weight_norm)


  # Estimate and sampling variance samp$new_strata <- as.factor(samp$new_strata)
  des2 <- e.svydesign(data=samp, ids=~id, strata = ~strata, weights=~weight_norm)
  est3 <- svystatTM(des2,estimator = "Mean", y=~Sepal.Width.obs, conf.int = TRUE, conf.lev = 0.95)

  # Quick check - is it same as survey? Yes it is
  # des2_test_survey <- svydesign(ids = ~id, data = samp, strata = ~ strata, weights = ~weight_norm)
  # est3_test_survey <- svymean(~Sepal.Width.obs, design = des2_test_survey)

  #####
  ## Strategy 4: Add weights as Thomas/Pam proposed
  #####

  # Wave 1 probs
  wave1_data <- data_sim
  samp1 <- dplyr::filter(wave1_data, sampled_wave1 == 1)
  prob1 <-  wave1_allocation
  prob1$npop <- c(table(data_sim$strata))
  prob1$probs <- prob1$n_to_sample/prob1$npop
  prob1 <- dplyr::select(prob1, strata, npop, probs)
  samp1 <- dplyr::left_join(samp1,prob1, by = "strata")

  # Wave 2 probs
  wave2_data <- dplyr::filter(data_sim, sampled_wave1 == 0)
  samp2 <- dplyr::filter(wave2_data, sampled_wave2 == 1)
  prob2 <- wave2_allocation
  prob2$probs <- (1-prob1$probs)*(prob2$n_to_sample/(prob2$npop - prob2$nsample_prior)) #Prob not sampled in wav1*prob yes in wave2
  samp2 <- dplyr::left_join(samp2,dplyr::select(prob2, strata, npop, probs), by = "strata")

  # Wave 3 probs
  wave3_data <- dplyr::filter(data_sim, sampled_wave1 == 0 & sampled_wave2 == 0)
  samp3 <- dplyr::filter(wave3_data, sampled_wave3 == 1)
  prob3 <- wave3_allocation
  prob3$probs <- (1-prob1$probs)*(1-prob2$probs)*(prob3$n_to_sample/(prob3$npop - prob3$nsample_prior))
  samp3 <- dplyr::left_join(samp3,dplyr::select(prob3, strata, npop, probs), by = "strata")


  # Pooling: the pooled sample represent the whole first phase population
  samp <- rbind(samp1,samp2,samp3)
  samp$weight <- 1/samp$probs


  # Merge back into full data for twophase
  data_sim <- data_sim %>%
    dplyr::left_join(dplyr::select(samp, id, npop, probs), by = "id")


  # Estimate and sampling variance samp$new_strata <- as.factor(samp$new_strata)
  mydesign4 <- twophase(id = list(~id, ~id), strata = list(NULL, ~strata),
                        probs = list(NULL, ~probs),
                        subset = ~as.logical(already_sampled), data = data_sim)

  est4 <- svymean(~Sepal.Width.obs, design = mydesign4)
  confints4 <- confint(est4)

  #####
  ## Strategy 5: Treat each as a separate survey
  #####

  # Wave 1 probs
  wave1_data <- data_sim
  samp1 <- dplyr::filter(wave1_data, sampled_wave1 == 1)
  prob1 <-  wave1_allocation
  prob1$npop <- c(table(data_sim$strata))
  prob1$myprobs <- prob1$n_to_sample/prob1$npop
  prob1 <- dplyr::select(prob1, strata, npop, myprobs)
  samp1 <- dplyr::left_join(samp1,prob1, by = "strata")

  # Wave 2 probs
  wave2_data <- dplyr::filter(data_sim, sampled_wave1 == 0)
  samp2 <- dplyr::filter(wave2_data, sampled_wave2 == 1)
  prob2 <- wave2_allocation
  prob2$myprobs <- prob2$n_to_sample/prob2$npop
  samp2 <- dplyr::left_join(samp2,dplyr::select(prob2, strata, npop, myprobs), by = "strata")

  # Wave 3 probs
  wave3_data <- dplyr::filter(data_sim, sampled_wave1 == 0 & sampled_wave2 == 0)
  samp3 <- dplyr::filter(wave3_data, sampled_wave3 == 1)
  prob3 <- wave3_allocation
  prob3$myprobs <- prob3$n_to_sample/prob3$npop
  samp3 <- dplyr::left_join(samp3,dplyr::select(prob3, strata, npop, myprobs), by = "strata")


  # Pooling: the pooled sample represent the whole first phase population
  samp <- rbind(samp1,samp2,samp3)
  samp$weight <- 1/samp$myprobs


  # Merge back into full data for twophase
  data_sim <- data_sim %>%
    dplyr::left_join(dplyr::select(samp, id, npop, myprobs), by = "id")


  # Estimate and sampling variance samp$new_strata <- as.factor(samp$new_strata)
  mydesign5 <- twophase(id = list(~id, ~id), strata = list(NULL, ~strata),
                        probs = list(NULL, ~myprobs),
                        subset = ~as.logical(already_sampled), data = data_sim)

  est5 <- svymean(~Sepal.Width.obs, design = mydesign5)
  confints5 <- confint(est5)

  # Check: is this same (point estimate, that is) as pooling result of three
  # different surveys, giving each same weight (because same size)
  # mydesign5.1 <- svydesign(ids = ~id, strata = ~strata, probs = ~probs,
  #                       data = samp1)
  # est5.1 <- svymean(~Sepal.Width.obs, design = mydesign5.1)
  # mydesign5.2 <- svydesign(ids = ~id, strata = ~strata, probs = ~probs,
  #                         data = samp2)
  # est5.2 <- svymean(~Sepal.Width.obs, design = mydesign5.2)
  # mydesign5.3 <- svydesign(ids = ~id, strata = ~strata, probs = ~probs,
  #                          data = samp3)
  # est5.3 <- svymean(~Sepal.Width.obs, design = mydesign5.3)
  # mean(c(est5.1, est5.2, est5.3))

  ## IT IS!


  return(c(est1[1], SE(est1), confints1[1], confints1[2],
           est2[1], SE(est2), confints2[1], confints2[2],
           est3[1], est3[2], est3[3], est3[4],
           est4[1], SE(est4), confints4[1], confints4[2],
           est5[1], SE(est5), confints5[1], confints5[2]))
}

########
#### Run simulations ----------------------------------------------
#########


### Run this analysis repeatedly
estimates1 <- c()
estimates2 <- c()
estimates3 <- c()
estimates4 <- c()
estimates5 <- c()
se1 <- c()
se2 <- c()
se3 <- c()
se4 <- c()
se5 <- c()
lower1 <- c()
lower2 <- c()
lower3 <- c()
lower4 <- c()
lower5 <- c()
upper1 <- c()
upper2 <- c()
upper3 <- c()
upper4 <- c()
upper5 <- c()

nreps <- 1000
for (i in 1:nreps){
  results <- run_sim_pstrat(n_per_wave = my_n_per_wave)
  estimates1 <- c(estimates1, results[1])
  estimates2 <- c(estimates2, results[5])
  estimates3 <- c(estimates3, results[9])
  estimates4 <- c(estimates4, results[13])
  estimates5 <- c(estimates5, results[17])
  se1 <- c(se1, results[2])
  se2 <- c(se2, results[6])
  se3 <- c(se3, results[10])
  se4 <- c(se4, results[14])
  se5 <- c(se5, results[18])
  lower1 <- c(lower1, results[3])
  lower2 <- c(lower2, results[7])
  lower3 <- c(lower3, results[11])
  lower4 <- c(lower4, results[15])
  lower5 <- c(lower5, results[19])
  upper1 <- c(upper1, results[4])
  upper2 <- c(upper2, results[8])
  upper3 <- c(upper3, results[12])
  upper4 <- c(upper4, results[16])
  upper5 <- c(upper5, results[19])
}

### True mean
true_mean <- mean(c(3.428, 2.77, 2.974))

### orcale_SE function
cover <- function(true, est, SE){
  ## return indicator mu in the interval (est-1.96SE, est+1.96SE)
  return((true > est-qnorm(.975)*SE)*(true<est+qnorm(0.975)*SE))
}

### Output dataset
stats <- data.frame(case = c(1,2,3,4, 5),
                    true_mean = rep(true_mean, 5),
                    est = c(mean(unlist(estimates1)),
                            mean(unlist(estimates2)),
                            mean(unlist(estimates3)),
                            mean(unlist(estimates4)),
                            mean(unlist(estimates5))
                    ),
                    coverage = c(sum(true_mean >= lower1 & true_mean <= upper1)/nreps,
                                 sum(true_mean >= lower2 & true_mean <= upper2)/nreps,
                                 sum(true_mean >= lower3 & true_mean <= upper3)/nreps,
                                 sum(true_mean >= lower4 & true_mean <= upper4)/nreps,
                                 sum(true_mean >= lower4 & true_mean <= upper4)/nreps),
                    ASE = c(mean(unlist(se1)),
                            mean(unlist(se2)),
                            mean(se3$SE),
                            mean(unlist(se4)),
                            mean(unlist(se5))),
                    ESE = c(sqrt(var(unlist(estimates1))),
                            sqrt(var(unlist(estimates2))),
                            sqrt(var(unlist(estimates3))),
                            sqrt(var(unlist(estimates4))),
                            sqrt(var(unlist(estimates5)))),
                    RMSE = c(sqrt(mean((unlist(estimates1)- true_mean)^2)),
                            sqrt(mean((unlist(estimates2)- true_mean)^2)),
                            sqrt(mean((unlist(estimates3)- true_mean)^2)),
                            sqrt(mean((unlist(estimates4)- true_mean)^2)),
                            sqrt(mean((unlist(estimates5)- true_mean)^2))),
                    Oracle_coverage = c(mean(cover(true_mean, unlist(estimates1), sd(unlist(estimates1)))),
                                        mean(cover(true_mean, unlist(estimates2), sd(unlist(estimates2)))),
                                        mean(cover(true_mean, unlist(estimates3), sd(unlist(estimates3)))),
                                        mean(cover(true_mean, unlist(estimates4), sd(unlist(estimates4)))),
                                        mean(cover(true_mean, unlist(estimates5), sd(unlist(estimates5))))))

stats$bias <- stats$est - true_mean
stats$bias_to_ese <- stats$bias/stats$ESE
stats

### Recall
# Case 1: Post-stratification (as I'm doing it)
# Case 2: Exact weights (Gustavo/Jasper style)
# Case 3: Reviewer weights
# Case 4: Pam/Thomas weights

