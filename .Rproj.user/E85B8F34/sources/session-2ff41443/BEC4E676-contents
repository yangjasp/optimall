#######
### Multiwave sampling Estimation Comparisons
#######

## In this script I use a simulated version of the iris dataset
## (n=996) to conduct a simple
## simulation example of (three-wave) multiwave sampling.
## Over 1,000 iterations (randomness only comes from sampling, as the
## dataset itself is fixed), I conduct stratified sampling
## to sample from the 3 strata of species, with proportional allocation
## in Wave 1 and then use Neyman allocation in Waves 2 and 3. I then
## estimate the mean Sepal Width using 3 different strategies


######
### Load packages ------------------------------------------------------
#####
library(datasets)
library(dplyr)
library(optimall)
library(survey)

#######
### Set parameters -------------------------------------------------
########
set.seed(02262023)
my_n_per_wave <- 48 # Number of samples per wave - total n will be 3 times this

#######
### Function for one iteration --------------------------------------------
#######
run_sim_pstrat <- function(n_per_wave = 48){

  #####
  ## Generate data
  #####
  n <- c(rmultinom(1, 996, c(1/3, 1/3, 1/3)))
  col1 <- c(rep("setosa", times = n[1]),
            rep("versicolor", times = n[2]),
            rep("virginica", times = n[3]))
  sl <- c(rnorm(n[1], 5.006, 0.124),
          rnorm(n[2], 5.936, 0.266),
          rnorm(n[3], 6.588, 0.404))
  pl <- c(rnorm(n[1], 1.462, 0.173),
          rnorm(n[2], 4.260, 0.470),
          rnorm(n[3], 5.552, 0.552))
  full_data <- data.frame("id" = 1:996,
                          "Species" = as.factor(col1),
                          "Sepal.Length" = sl,
                          "Petal.Length" = pl)
  phase1_data <- full_data[,-4]

  ####
  ## Multiwave object setup
  ####

  Survey <- multiwave(phases = 2, waves = c(1, 3),
                      phase1 = phase1_data)

  set_mw(Survey, phase = 2, slot = "metadata") <- list(id = "id",
                                                       strata = "Species",
                                                       design_strata = "strata",
                                                       include_probs = TRUE)

  ####
  ## Wave 1
  ####

  ### Allocation: X-allocate with Phase 1 sepal length
  Survey <- apply_multiwave(Survey, phase = 2, wave = 1,
                            fun = "optimum_allocation",
                            y = "Sepal.Length",
                            nsample = 50, method = "Neyman")

  # get_mw(Survey, phase = 2, wave = 1, slot ="design")

  ### Select samples
  Survey <- apply_multiwave(Survey, phase = 2, wave = 1,
                            fun = "sample_strata",
                            n_allocated = "stratum_size",
                            probs = ~stratum_size/npop)

  ### "Collect" data
  set_mw(Survey, phase = 2, wave = 1, slot = "sampled_data") <-
    full_data[full_data$id %in% get_mw(Survey, phase = 2, wave = 1,
                                       slot = "samples")$ids,
              c("id", "Petal.Length")]

  Survey <- merge_samples(Survey, phase = 2, wave = 1)

  ####
  ## Wave 2
  ####

  ### Allocation: Neyman allocation with already-collected phase 2 data.
  Survey <- apply_multiwave(Survey, phase = 2, wave = 2,
                            fun = "allocate_wave",
                            y = "Petal.Length",
                            nsample = 50, allocation_method = "Neyman",
                            already_sampled = "sampled_phase2")

  # get_mw(phase = 2, wave = 2, slot = "design")

  ### Select samples
  Survey <- apply_multiwave(Survey, phase = 2, wave = 2,
                            fun = "sample_strata",
                            n_allocated = "n_to_sample",
                            probs = ~n_to_sample/(npop - nsample_prior),
                            already_sampled = "sampled_phase2")

  ### "Collect" data
  set_mw(Survey, phase = 2, wave = 2, slot = "sampled_data") <-
    full_data[full_data$id %in% get_mw(Survey, phase = 2, wave = 2,
                                       slot = "samples")$ids,
              c("id", "Petal.Length")]
  Survey <- merge_samples(Survey, phase = 2, wave = 2)

  ####
  ## Wave 3
  ####

  ### Allocation: Neyman allocation with already-collected phase 2 data.
  Survey <- apply_multiwave(Survey, phase = 2, wave = 3,
                            fun = "allocate_wave",
                            y = "Petal.Length",
                            nsample = 50, allocation_method = "Neyman",
                            already_sampled = "sampled_phase2")

  # get_mw(phase = 2, wave = 3, slot = "design")

  ### Select samples
  Survey <- apply_multiwave(Survey, phase = 2, wave = 3,
                            fun = "sample_strata",
                            n_allocated = "n_to_sample",
                            probs = ~n_to_sample/(npop - nsample_prior),
                            already_sampled = "sampled_phase2")

  ### "Collect" data
  set_mw(Survey, phase = 2, wave = 3, slot = "sampled_data") <-
    full_data[full_data$id %in% get_mw(Survey, phase = 2, wave = 3,
                                       slot = "samples")$ids,
              c("id", "Petal.Length")]
  Survey <- merge_samples(Survey, phase = 2, wave = 3)

  ### Final dataset for analysis
  survey_data <- get_mw(Survey, phase = 2, wave = 3, slot = "data")

  ### Clean up for printing
  survey_data <- survey_data[,c("id", "Species", "Sepal.Length",
                                "Petal.Length", "sampled_phase2",
                                "sampled_wave2.1", "sampled_wave2.2",
                                "sampled_wave2.3", "sampling_prob")]
  survey_data <- survey_data[order(-survey_data$sampled_phase2,
                                   survey_data$id), , drop = FALSE]


  #######
  #### 1. Post-stratification
  #######

  design <- twophase(id = list(~id, ~id), strata = list(NULL, ~Species),
                     subset = ~as.logical(sampled_phase2),
                     data = survey_data, method = "simple")
  pst_design <- calibrate(design, phase = 2, formula = ~Species)
  pst_est <- svymean(~Petal.Length, design = pst_design)
  pst_est_CI <- confint(pst_est)

  ######
  ##### 1b. Post-stratification with raking
  #######
  pst_design_rake <- calibrate(pst_design, ~Sepal.Length,
                               phase = 2, calfun = "raking")
  pst_est_rake <- svymean(~Petal.Length, design = pst_design_rake)
  pst_est_rake_CI <- confint(pst_est_rake)

  #######
  #### 2. Wave-specific conditional probabilities
  #######

  ### Only need pairwise probs for elements sampled in phase 2
  phase2_data <- survey_data[survey_data$sampled_phase2 == 1,]
  phase2_data <- dplyr::mutate(phase2_data,
                               phase2_wave = case_when(sampled_wave2.1 == 1 ~ 1,
                                                       sampled_wave2.2 == 1 ~ 2,
                                                       sampled_wave2.3 == 1 ~ 3))

  ### Using design slots, add column with n_k and N_k for each wave
  designW123 <- dplyr::bind_rows(cbind(phase2_wave = 1,
                                       get_mw(Survey, 2, 1, "design")),
                                 cbind(phase2_wave = 2,
                                       get_mw(Survey, 2, 2, "design")),
                                 cbind(phase2_wave = 3,
                                       get_mw(Survey, 2, 3, "design")))

  ### Merge any differing column names, compute dependent probability as n_k/N_k*
  ### n_k/(N_k-1), merge with phase2_data
  designW123 <- designW123 |>
    dplyr::mutate(n_to_sample = dplyr::coalesce(n_to_sample, stratum_size),
                  nsample_prior = ifelse(is.na(nsample_prior),
                                         0 , nsample_prior),
                  dependent_prob = n_to_sample/(npop - nsample_prior)*
                    n_to_sample/(npop - nsample_prior - 1)) #n/N*n/(N-1)

  phase2_data <- phase2_data |>
    dplyr::left_join(designW123, by = c("Species" = "strata", "phase2_wave"))

  ### Create pairwise probability matrix.
  ### For independent obs, just take product. Otherwise take dependent prob
  independent_probs <- with(phase2_data, outer(sampling_prob, sampling_prob, "*"))
  dependent_probs <- with(phase2_data,
                          outer(sqrt(dependent_prob),
                                sqrt(dependent_prob), "*"))

  # Logical of whether independent or dependent,
  is_dependent <- with(phase2_data, outer(Species, Species, "==")) &
    with(phase2_data, outer(phase2_wave, phase2_wave, "=="))

  # Final matrix keeps dependent or independent
  pairwise_probs <- ifelse(is_dependent, dependent_probs, independent_probs)

  # Replace diag with element sampling probs
  diag(pairwise_probs) <- phase2_data$sampling_prob

  # Construct estimator
  cp_design <- twophase(id = list(~id, ~id), strata = list(NULL, ~Species),
                        subset = ~as.logical(sampled_phase2),
                        data = survey_data, probs = list(~NULL, pairwise_probs))

  cp_est <- svymean(~Petal.Length, design = cp_design)
  cp_est_CI <- confint(cp_est)

  ######
  ##### 2b. Conditional probs with raking
  #######
   # cp_design_rake <- calibrate(cp_design, formula = ~Sepal.Length,
   #                            phase = 2, calfun = "raking")
   # cp_est_rake <- svymean(~Petal.Length, design = cp_design_rake)
   # cp_est_rake_CI <- confint(pst_est_rake)
  cp_est_rake <- svymean(~Petal.Length, design = cp_design)
  cp_est_rake_CI <- confint(cp_est_rake)

  ######
  ##### 3. Reviewer's way, but giving weights to twophase()
  ######

  # Wave 1 weights
  data_sim <- phase2_data
  wave1_data <- data_sim
  samp1 <- dplyr::filter(data_sim, sampled_wave2.1 == 1)
  wgt1 <- as.data.frame(table(wave1_data$Species) / table(wave1_data$Species[wave1_data$sampled_wave2.1==1]))
  colnames(wgt1) <- c("Species","weight")
  samp1 <- dplyr::left_join(samp1,wgt1, by = "Species")
  sum(samp1$weight)

  # Wave 2 weights
  wave2_data <- dplyr::filter(data_sim, sampled_wave2.1 == 0)
  samp2 <- dplyr::filter(data_sim, sampled_wave2.2 == 1)
  samp2$weight <- (samp2$npop-samp2$nsample_prior)/samp2$n_to_sample
  sum(samp2$weight)

  # Wave 3 weights
  wave3_data <- dplyr::filter(data_sim,
                              sampled_wave2.1 == 0 & sampled_wave2.2 == 0)
  samp3 <- dplyr::filter(data_sim, sampled_wave2.3 == 1)
  samp3$weight <- (samp3$npop-samp3$nsample_prior)/samp3$n_to_sample
  sum(samp3$weight)

  # Normalization of weights: the sum of weights of the overall sample # must reproduce the total of units of first phase (10335), but the # contribution of each sample is made proportional to the different # subpopulations represented

  total <- sum(samp1$weight) + sum(samp2$weight) + sum(samp3$weight)
  samp1$weight_norm <- samp1$weight * (sum(nrow(data_sim)/sum(samp1$weight))) * sum(samp1$weight) /total
  sum(samp1$weight_norm)

  samp2$weight_norm <- samp2$weight * (sum(nrow(data_sim)/sum(samp2$weight))) * sum(samp2$weight) / total
  sum(samp2$weight_norm)

  samp3$weight_norm <- samp3$weight * (sum(nrow(data_sim)/sum(samp3$weight))) * sum(samp3$weight) / total
  sum(samp3$weight_norm)

  # Pooling: the pooled sample represent the whole first phase population
  samp <- data.frame(rbind(samp1,samp2,samp3))
  sum(samp$weight_norm)

  # Estimate and sampling variance samp$new_strata <- as.factor(samp$new_strata)
  pool_design <- twophase(data=samp, id=list(~id, ~id),
                          strata = list(NULL, ~Species),
                          subset = ~as.logical(sampled_phase2),
                          method = "approx")#,
                          #weights= ~list(NULL, ~weight_norm))


  pool_est <- svymean(~Petal.Length, design = pool_design)
  pool_est
  pool_est_CI <- confint(pool_est)


  return(c(pst_est[1], SE(pst_est), pst_est_CI[1], pst_est_CI[2],
           pst_est_rake[1], SE(pst_est_rake), pst_est_rake_CI[1],
           pst_est_rake_CI[2],
           cp_est[1], SE(cp_est), cp_est_CI[1], cp_est_CI[2],
           cp_est_rake[1], SE(cp_est_rake), cp_est_rake_CI[1],
           cp_est_rake_CI[2],
           pool_est[1], SE(pool_est), pool_est_CI[1], pool_est_CI[2]))
}

########
#### Run simulations ----------------------------------------------
#########


### Run this analysis repeatedly
estimates1 <- c()
estimates2 <- c()
estimates3 <- c()
estimates4 <- c()
estimates5 <- c()
se1 <- c()
se2 <- c()
se3 <- c()
se4 <- c()
se5 <- c()
lower1 <- c()
lower2 <- c()
lower3 <- c()
lower4 <- c()
lower5 <- c()
upper1 <- c()
upper2 <- c()
upper3 <- c()
upper4 <- c()
upper5 <- c()

nreps <- 1000
for (i in 1:nreps){
  results <- run_sim_pstrat(n_per_wave = my_n_per_wave)
  estimates1 <- c(estimates1, results[1])
  estimates2 <- c(estimates2, results[5])
  estimates3 <- c(estimates3, results[9])
  estimates4 <- c(estimates4, results[13])
  estimates5 <- c(estimates5, results[17])
  se1 <- c(se1, results[2])
  se2 <- c(se2, results[6])
  se3 <- c(se3, results[10])
  se4 <- c(se4, results[14])
  se5 <- c(se5, results[18])
  lower1 <- c(lower1, results[3])
  lower2 <- c(lower2, results[7])
  lower3 <- c(lower3, results[11])
  lower4 <- c(lower4, results[15])
  lower5 <- c(lower5, results[19])
  upper1 <- c(upper1, results[4])
  upper2 <- c(upper2, results[8])
  upper3 <- c(upper3, results[12])
  upper4 <- c(upper4, results[16])
  upper5 <- c(upper5, results[19])
}

### True mean
true_mean <- mean(c(1.462, 4.260, 5.552))

### oracle_SE function
cover <- function(true, est, SE){
  ## return indicator mu in the interval (est-1.96SE, est+1.96SE)
  return((true > est-qnorm(.975)*SE)*(true<est+qnorm(0.975)*SE))
}

### Output dataset
stats <- data.frame(case = c(1,2,3,5),
                    true_mean = rep(true_mean, 4),
                    est = c(mean(unlist(estimates1)),
                            mean(unlist(estimates2)),
                            mean(unlist(estimates3)),
                            mean(unlist(estimates5))
                    ),
                    coverage = c(sum(true_mean >= lower1 & true_mean <= upper1)/nreps,
                                 sum(true_mean >= lower2 & true_mean <= upper2)/nreps,
                                 sum(true_mean >= lower3 & true_mean <= upper3)/nreps,
                                 sum(true_mean >= lower5 & true_mean <= upper5)/nreps),
                    ASE = c(mean(unlist(se1)),
                            mean(unlist(se2)),
                            mean(unlist(se3)),
                            mean(unlist(se5))),
                    ESE = c(sqrt(var(unlist(estimates1))),
                            sqrt(var(unlist(estimates2))),
                            sqrt(var(unlist(estimates3))),
                            sqrt(var(unlist(estimates5)))),
                    RMSE = c(sqrt(mean((unlist(estimates1)- true_mean)^2)),
                            sqrt(mean((unlist(estimates2)- true_mean)^2)),
                            sqrt(mean((unlist(estimates3)- true_mean)^2)),
                            sqrt(mean((unlist(estimates5)- true_mean)^2))),
                    Oracle_coverage = c(mean(cover(true_mean, unlist(estimates1), sd(unlist(estimates1)))),
                                        mean(cover(true_mean, unlist(estimates2), sd(unlist(estimates2)))),
                                        mean(cover(true_mean, unlist(estimates3), sd(unlist(estimates3)))),
                                        mean(cover(true_mean, unlist(estimates5), sd(unlist(estimates5))))))

stats$bias <- stats$est - true_mean
stats$bias_to_ese <- stats$bias/stats$ESE
stats

### Recall
# Case 1: Post-stratification (as I'm doing it)
# Case 2: Exact weights (Gustavo/Jasper style)
# Case 3: Reviewer weights
# Case 4: Pam/Thomas weights
# Case 5: Different surveys

