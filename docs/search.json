[{"path":"https://yangjasp.github.io/optimall/articles/Multiwave-Estimation.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Estimation in Two-phase, Multi-wave sampling","text":"Two-phase, multi-wave sampling appealing strategy design validation studies large set data available whole cohort, variables interest can observed subset cohort. classic example inexpensive error-prone data available everyone (phase ), error-free gold standard data available subset (phase II) (McIsaac Cook 2015, Chen Lumley 2020, Shepherd et al. 2023). One optimall’s primary objectives facilitate implementation two-phase, multi-wave sampling designs R, focusing particularly optimum allocation samples, stratification, storage relevant information design stage. optimall workflow designed blend smoothly packages specific estimation stage, comprehensive survey package, optimall offer functions estimation. Nevertheless, estimation ultimate goal survey. vignette describes estimation survey package can conducted survey designed optimall. begins brief summary theoretical considerations multi-phase multi-wave sampling. presents two estimators can used settings demonstrates can calculated using optimall survey. final section presents results simulations comparing estimators. cases, post-stratified weights lead efficient estimators.","code":""},{"path":[]},{"path":"https://yangjasp.github.io/optimall/articles/Multiwave-Estimation.html","id":"design-based-estimation-ipw-and-generalized-raking-in-a-single-phase-wave","dir":"Articles","previous_headings":"Theoretical background","what":"Design-based estimation: IPW and Generalized Raking in a Single Phase, Wave","title":"Estimation in Two-phase, Multi-wave sampling","text":"Broadly, two classes survey estimators: design-based model-based. vignette focuses design-based estimators, typically constructed assigning weights sample observations based probabilistic properties sampling design. simple example design-based estimator single phase design Horwitz-Thompson inverse probability weighted (IPW) estimator population total \\(Y_t\\), \\[ \\hat{T}_{IPW} = \\sum_{=1}^N R_i\\frac{y_i}{\\pi_i}, \\] individuals poulation size \\(N\\) indexed \\(= 1, ..., N\\), \\(R_i\\) indicator inclusion individual \\(\\) sample, \\(\\pi_i\\) sampling probability person \\(\\), \\(y_i\\) observed value. simple stratified sampling, \\(\\pi_i = \\frac{n_k}{N_k}\\) individuals stratum, \\(k= 1, ..., K\\), \\(n_k\\) denotes sample size stratum \\(k\\) \\(N_k\\) denotes population size stratum \\(h\\). case, IPW estimator becomes \\[ \\hat{T}_{IPW} = \\sum_{k=1}^K\\sum_{\\I_k}R_i\\frac{N_k}{n_k}y_i, \\] \\(I_k\\) set indices individuals stratum \\(k\\). estimator unbiased population total, variance may large sampling fractions small strata. Neyman Wright allocations can implemented optimall optimal estimator. Efficient alternatives IPW estimators exist prior information entire population available. popular design-based estimator presence known auxiliary variables generalized raking estimator, improves IPW adjusting weights ensure estimated totals auxiliary variables match known phase 1 totals (Breslow et al. 2009). Let \\(x_i\\) auxilary variable observed whole phase 1 cohort correlated variable interest \\(y_i\\). Generalized raking adjusts individual inverse-probability weight factor \\(g_i\\). simple stratified sampling, \\(w^*_i = \\frac{g_i}{\\pi_i} = g_i\\frac{N_k}{n_k}\\) estimator \\[ \\hat{T}_{GR} = \\sum_{k=1}^K\\sum_{\\I_k}R_iw^*_iy_i = \\sum_{k=1}^K\\sum_{\\I_k}R_ig_i\\frac{N_k}{n_k}y_i , \\] \\(g_i\\) chosen \\[ \\sum_{k=1}^K\\sum_{\\I_k}R_ig_i\\frac{N_k}{n_k}x_i = \\sum_{=1}^N x_i \\] Many \\(g_i\\) values may satisfy condition, new weights chosen close possible IPW weights based minimization pre-specified distance metric \\(\\sum_{=1}^NR_id(g_i\\frac{1}{\\pi_i}, \\frac{1}{\\pi_i})\\). auxiliary variable correlated variable interest, generalized raking efficient traditional IPW estimators. Neyman Wright allocations nearly optimal generalized raking (Chen Lumley 2022).","code":""},{"path":"https://yangjasp.github.io/optimall/articles/Multiwave-Estimation.html","id":"special-considerations-for-two-phase-sampling","dir":"Articles","previous_headings":"Theoretical background","what":"Special considerations for Two-phase sampling","title":"Estimation in Two-phase, Multi-wave sampling","text":"Two-phase sampling involves collecting large sample relatively inexpensive variables phase 1 collecting expensive variables subset phase 1 samples phase 2. Rather treating phase 1 cohort population phase 2 single sample , typical two-phase approach considers phase 1 sample even larger super-population interest. key feature two-phase sampling information collected phase 1 used inform efficient phase 2 sampling design. example, standard deviation estimates required Neyman allocation phase 2 can approximated phase 1 (Neyman 1938). side effect gain efficiency marginal inclusion probabilities, \\(\\pi_i\\), elements sampled phase 2 unknown calculation requires consideration phase 2 sampling designs arise every possible phase 1. Specifically, exact inclusion probability \\(\\pi_i\\) two-phase design \\[ \\pi_i = \\sum_{s_a}R_{ai} P(s_a)\\pi_{|s_a} \\] \\(s_a\\) phase 1 sample, \\(P(s_a)\\) probability given \\(s_a\\) realized, \\(R_{ai}\\) indicator inclusion element \\(\\) given phase 1 sample \\(\\pi_i|{s_a}\\) depends results \\(s_a\\), \\(\\pi_i|{s_a}\\) known realized \\(s_a\\). limitation make standard IPW techniques infeasible two phase setting, approaches required construct unbiased estimators approximate variances. Chapter 9 Särndal et al. (1992) details special considerations required construct estimators. , briefly describe important results case stratified random sampling used phase 2 based strata defined phase 1 variables. Consider strata \\(k = 1,...,K\\). Let \\(N\\) population size, \\(n_a\\) phase 1 sample size, \\(n\\) phase 2 sample size. Denote \\(n_{ak}\\) \\(n_k\\) phase 1 phase 2 sample sizes respectively stratum \\(k\\). unbiased design-based estimator population total \\(T = \\sum_{=1}^N y_i\\) \\[\\begin{equation} \\tag{1} \\label{eq:eq1} \\hat{T}_{TP} = \\sum_{\\I_{s_a}}\\frac{1}{\\pi_{ai}\\pi_{|s_a}}y_i, \\end{equation}\\] \\(\\pi_{ai}\\) phase 1 sampling probability element \\(\\), \\(\\pi_{|s_1}\\) phase 2 sampling probability given realized phase 1 sample, denoted \\(s_a\\), \\(I_{s_a}\\) set indices individuals sampled \\(s_a\\). idea estimator estimate IPW estimator produced \\(y_i\\) observed entire phase 1 sample \\(s_a\\). sense, \\(\\hat{T}_{TP}\\) estimator estimator. Accordingly, variance straightforward, Särndal et al. show can written \\[\\begin{equation} \\tag{2} \\label{eq:eq2} V(\\hat{T}_{TP}) = \\sum_{=1}^N\\sum_{j=1}^N \\text{Cov}(R_{ai}, R_{aj})\\frac{y_i}{\\pi_{a_i}} \\frac{y_j}{\\pi_{aj}} + \\mathbb{E}\\left[\\sum_{\\I_{s_a}}\\sum_{j \\I_{s_a}} \\text{Cov}(R_i, R_j|S_a) \\frac{y_i}{\\pi_{ai}\\pi_{|s_a}}\\frac{y_j}{\\pi_{aj}\\pi_{j|s_a}} \\right], \\end{equation}\\] \\(R_{ai}\\) \\(R_{aj}\\) phase 1 sample inclusion indicators elements \\(\\) \\(j\\), \\(R_{}\\) \\(R_{j}\\) phase 2 sample inclusion indicators. expectation second term respect phase 1 design. variance estimated unbiasedly \\[\\begin{equation} \\tag{3} \\label{eq:eq3} \\hat{V}(\\hat{T}_{TP}) = \\sum_{\\I_{s_a}}\\sum_{j \\I_{s_a}} R_{}R_{j} \\frac{\\text{Cov}(R_{ai}, R_{aj})}{\\pi_{aij}\\pi_{ij|s_a}}\\frac{y_i}{\\pi_{a_i}} \\frac{y_j}{\\pi_{aj}} + \\sum_{\\I_{s_a}}\\sum_{j \\I_{s_a}} R_{}R_{j} \\frac{\\text{Cov}(R_i, R_j|S_a)}{\\pi_{ij|s_a}} \\frac{y_i}{\\pi_{ai}\\pi_{|s_a}}\\frac{y_j}{\\pi_{aj}\\pi_{j|s_a}}. \\end{equation}\\] phase 1 simple random sample phase 2 stratified random sample, \\[ \\hat{T}_{TP} = \\sum_{k=1}^K\\sum_{\\I_{k}}R_i\\frac{N}{n_a}\\frac{n_{ak}}{n_{k}}y_i = \\frac{N}{n_a}\\sum_{k=1}^K\\frac{n_{ak}}{n_{k}}\\sum_{\\I_k}R_iy_i, \\] \\[ V(\\hat{T}_{TP}) = N^2\\frac{1 - \\frac{n_a}{N}}{n_a}\\text{Var}_\\text{pop}(y) + \\mathbb{E}\\left[N^2\\sum_{k=1}^K (\\frac{n_{ak}}{n_a})^2\\frac{1-\\frac{n_k}{n_{ak}}}{n_k}\\text{Var}_{s_{ak}}(y) \\right], \\] \\(\\text{Var}_\\text{pop}(y)\\) variance \\(y\\) population \\(\\text{Var}_{s_{ak}}(y)\\) variance stratum \\(k\\) phase 1 sample. variance estimated unbiasedly \\[\\begin{equation} \\tag{4} \\label{eq:eq4} \\hat{V}(\\hat{T}_{TP}) = N(N-1)\\sum_{k=1}^K\\left(\\frac{n_{ak}-1}{n_a-1} - \\frac{n_k - 1}{N-1}\\right)\\frac{n_{ak}S^2_{y,s_k}}{n_a n_k} + \\\\ \\frac{N(N-n_a)}{n_a-1}\\sum_{k=1}^K \\frac{n_{ak}}{n_a}\\left(\\frac{1}{n_k}\\sum_{=1}^{n_k}R_iy_i - \\frac{1}{N}\\sum_{k=1}^K\\sum_{\\I_k}R_i\\frac{N}{n_a}\\frac{n_{ak}}{n_{k}}y_i\\right)^2, \\end{equation}\\] \\(S^2_{y,s_k}\\) phase 2 sample variance \\(y\\) stratum \\(k\\). twophase() function survey package uses (\\(\\ref{eq:eq3}\\)) calculate variance method \"full\" (\\(\\ref{eq:eq4}\\)) method \"approx\" \"simple\".","code":""},{"path":"https://yangjasp.github.io/optimall/articles/Multiwave-Estimation.html","id":"two-phase-multi-wave-sampling","dir":"Articles","previous_headings":"Theoretical background","what":"Two-phase, multi-wave sampling","title":"Estimation in Two-phase, Multi-wave sampling","text":"efficiency gains collecting auxilary information phase 1 can improved even breaking phase 2 waves updating sampling design wave. Consider collecting \\(n\\) samples across \\(T\\) waves, sample size \\(t\\)-th wave (\\(t = 1, ...,T\\)) denoted \\(n_t\\). approach presents similar challenge multi-phase setting, results wave \\(t\\) influence allocation, therefore sampling probabilities, waves \\(t^* > t\\). Broadly, two-phase, multi-wave sampling design consists following steps: Phase 1: Draw \\(n_a\\) samples population Phase 1 according SRS () design. Construct strata (indexed \\(h = 1, ..., H\\)) based information gathered Phase 1. Phase 2, Wave 1: Allocate samples strata according optimum allocation determined using estimates optimality parameters phase 1 data. Phase 2, Wave 2: Allocate samples strata according optimum allocation determined using estimates optimality parameters phase 2, wave 1 data. ⋮ Phase 2, Wave T: Allocate samples strata according optimum allocation determined using estimates optimality parameters data collected prior waves phase 2.","code":""},{"path":"https://yangjasp.github.io/optimall/articles/Multiwave-Estimation.html","id":"estimation-approaches-after-two-phase-multi-wave-sampling","dir":"Articles","previous_headings":"","what":"Estimation approaches after two-phase, multi-wave sampling","title":"Estimation in Two-phase, Multi-wave sampling","text":", present three potential estimators population total two-phase, multi-wave sampling.","code":""},{"path":"https://yangjasp.github.io/optimall/articles/Multiwave-Estimation.html","id":"post-stratification","dir":"Articles","previous_headings":"Estimation approaches after two-phase, multi-wave sampling","what":"1. Post-stratification","title":"Estimation in Two-phase, Multi-wave sampling","text":"examples contained optimall package vignettes use post-stratification weights conduct estimation. discussed Holt Smith (1979), Valliant (1993) Lumley, Shaw, Dai (2011), post-stratification robust efficient estimation method assigns weights sample elements based strata constructed sample collected rather relying pre-specified sampling probabilities traditional IPW estimators . approach useful multi-wave sampling setting require computation exact, even wave-conditional, inclusion probabilities (variance estimation involve pairwise inclusion probabilities). Instead, post-stratification approach assigns weight every member stratum \\(k\\), \\(\\frac{N_k}{n_k} = \\frac{N_k}{\\sum_{t=1}^T n_{tk}}\\), \\(n_{tk}\\) number samples selected stratum \\(k\\) wave \\(t\\). weight inverse final sampling fractions, reflects exact IPW weights final allocation obtained single wave. final estimator simple calculate takes form \\[ \\hat{T}_{POST} = \\sum_{k=1}^K\\sum_{\\I_k}R_i\\frac{N_k}{n_k}y_i, \\] Conveniently, post-stratification can viewed simple case generalized raking. Thus, Neyman Wright allocations still approximately optimal (Chen Lumley 2022).","code":""},{"path":"https://yangjasp.github.io/optimall/articles/Multiwave-Estimation.html","id":"wave-specific-conditional-probabilties","dir":"Articles","previous_headings":"Estimation approaches after two-phase, multi-wave sampling","what":"2. Wave-specific conditional probabilties","title":"Estimation in Two-phase, Multi-wave sampling","text":"Consider unbiased two-phase estimator population total (\\(\\ref{eq:eq1}\\)), , stratified random sampling used Phase 2, can written: \\[\\begin{equation} \\tag{5} \\label{eq:eq5} \\hat{T}_{TP} = \\sum_{\\I_{s_a}}\\frac{1}{\\pi_{ai}\\pi_{|s_a}}y_i  = \\sum_{k=1}^K \\sum_{\\I_{k, s_a}} \\frac{1}{\\pi_{ai}\\pi_{k|s_a}}y_i, \\end{equation}\\] \\(\\pi_{k|s_a}\\) phase 2 sampling probability observations stratum \\(k\\) conditional observed Phase 1, \\(I_{k, s_a}\\) set indices individuals sampled \\(s_a\\) stratum \\(k\\). \\(\\pi_{ai}\\) can determined Phase 1 design, \\(\\pi_{\\cdot|s_a}\\) becomes complex Phase 2 conducted multiple waves, result wave affects sampling probabilities subsequent waves. natural extension (\\(\\ref{eq:eq5}\\)) continue conditioning probabilities wave. Now, however, element can sampled given wave sampled prior waves. two-phase, multi-wave sample \\(T\\) waves stratified random sampling phase 2, yield \\[\\begin{equation} \\tag{6} \\label{eq:eq6} \\hat{T}_{TP} = \\sum_{k=1}^K\\frac{1}{T_k}\\sum_{t^* = 1}^{T}\\sum_{\\I_{k,s_a, t^*}}\\frac{1}{\\pi_{ai}(1-\\pi_{k1|s_a})(1-\\pi_{k2|s_a, s_{b_1}}) \\cdots (1-\\pi_{k(t^*-1)|s_a, s_{b1},..., s_{b(t^*-2)}})\\pi_{kt^*|s_a, s_{b_1}, ..., s_{b_{t^*-1}}}}y_i, \\end{equation}\\] \\(I_{k, s_a,t^*}\\) now set sample indices elements stratum \\(k\\) sampled \\(s_a\\) wave \\(t^*\\) Phase 2. \\(\\pi_{kt|s_a, s_{b_1}, ..., s_{b_{t-1}}}\\) probability member stratum \\(k\\) sampled phase 2, wave t, conditional observed waves \\(b_1\\) \\(b_{t-1}\\). \\(T_k\\) number waves stratum \\(k\\) non-zero sampling probability, assumed \\(>0\\). simplicity, now denote denominator (Equation \\(\\ref{eq:eq6}\\)) \\(\\tilde{\\pi_i} := \\pi_{ai}(1-\\pi_{k1|s_a})(1-\\pi_{k2|s_a, s_{b_1}}) \\cdots (1-\\pi_{k(t^*-1)|s_a, s_{b1},..., s_{b(t^*-2)}})\\pi_{kt^*|s_a, s_{b_1}, ..., s_{b_{t^*-1}}}\\) estimator unbiased true population total, larger variance post-stratified estimator. , estimating standard errors even complicated traditional two-phase case (\\(\\ref{eq:eq2}\\)) wave contributes variance. variance estimator \\(\\hat{T}_{TP}\\) stratified random sampling without replacement Phase 2 follows form (Equation \\(\\ref{eq:eq3}\\)) (assuming simplicity \\(T_k = T\\) \\(\\forall\\) \\(k\\)): \\[\\begin{equation} \\tag{7} \\label{eq:eq7} \\hat{V}\\left(\\hat{T}_{TP}\\right)= \\underbrace{\\sum_{\\I_{s_a}}\\sum_{j \\I_{s_a}}  \\frac{\\text{Cov}(R_{ai}, R_{aj})}{\\pi_{aij}\\pi_{ij|s_a}}\\frac{y_i}{\\pi_{ai}} \\frac{y_j}{\\pi_{aj}}}_{\\text{Phase 1 contribution, (Eq. 3)}} \\\\ + \\frac{1}{T^2}\\sum_{k=1}^K \\sum_{t^*=1}^T\\sum_{, j \\{k,s_a, t^*}}\\left(1 - \\frac{\\tilde{\\pi_i}\\tilde{\\pi_j}}{\\frac{n_{kt^*}}{n_{ak} - \\sum_{t''<t^*}n_{kt''}}\\prod_{t' < t^*}(1-\\frac{n_{kt'}}{n_{ak} - \\sum_{t''<t'}n_{kt''}})(1-\\frac{n_{kt'}}{n_{ak} - \\sum_{t''<t'}n_{kt''}-1})}\\right)\\frac{y_i}{\\tilde{\\pi_i}}\\frac{y_j}{\\tilde{\\pi_j}} \\end{equation}\\] following section demonstrates compute estimator Rusing optimall survey. simulations end vignette, demonstrate performance post-stratification.","code":""},{"path":"https://yangjasp.github.io/optimall/articles/Multiwave-Estimation.html","id":"how-to-implement-each-strategy-with-optimall-and-survey","dir":"Articles","previous_headings":"","what":"How to implement each strategy with optimall and survey","title":"Estimation in Two-phase, Multi-wave sampling","text":"section demonstrate estimate population mean using three estimators defined previous section optimall survey. example, simulate phase 1 dataset n = 1,000 observations modelled iris dataset (see appendix). dataset contains information three species, use strata, assuming phase 1 drawn simple random sample superpopulation. Sepal Length Species available phase 1, Petal Length variable interest available phase 2. conduct phase 2 sampling three waves using optimall, collecting Petal Length 50 samples wave. final dataset looks like: code conduct multi-wave sampling generate data frame using optimall provided appendix.","code":"head(survey_data) #>    id Species Sepal.Length Petal.Length sampled_phase2 sampled_wave2.1 #> 22 22  setosa     2.278977    0.6026001              1               1 #> 50 50  setosa     4.088162    1.1976046              1               0 #> 67 67  setosa     4.841755    1.5282054              1               0 #> 71 71  setosa     5.739395    1.7258338              1               1 #> 73 73  setosa     3.669596    0.9204304              1               0 #> 77 77  setosa     5.194793    1.4941155              1               1 #>    sampled_wave2.2 sampled_wave2.3 sampling_prob wave #> 22               0               0    0.07485030    1 #> 50               0               1    0.05501618    3 #> 67               0               1    0.05501618    3 #> 71               0               0    0.07485030    1 #> 73               0               1    0.05501618    3 #> 77               0               0    0.07485030    1"},{"path":"https://yangjasp.github.io/optimall/articles/Multiwave-Estimation.html","id":"post-stratification-1","dir":"Articles","previous_headings":"How to implement each strategy with optimall and survey","what":"1. Post-stratification","title":"Estimation in Two-phase, Multi-wave sampling","text":"Post-stratification straightforward implement twophase function survey. start initializing two-phase design. Note use method = \"simple phase 1 simple random sample phase 2 stratified random sample. specified Species phase 2 stratification variable, can calculate post-stratified estimate directly using svymean() Survey package. Note another option use calibrate() function perform post-stratification using Species stratification variable. See “Two phase” vignette survey package information.","code":"pst_design <- twophase(id = list(~id, ~id), strata = list(NULL, ~Species),                        subset = ~as.logical(sampled_phase2),                        data = survey_data, method = \"simple\") pst_est <- svymean(~Petal.Length, design = pst_design) pst_est #>                mean     SE #> Petal.Length 3.7233 0.0708"},{"path":"https://yangjasp.github.io/optimall/articles/Multiwave-Estimation.html","id":"post-stratification-with-raking","dir":"Articles","previous_headings":"How to implement each strategy with optimall and survey > 1. Post-stratification","what":"Post-stratification with raking","title":"Estimation in Two-phase, Multi-wave sampling","text":"obtain even efficient estimator, can rake Sepal.Length stratification variable. also straightforward implement survey package.","code":"pst_design_rake <- calibrate(pst_design, ~Sepal.Length + Species,                              phase = 2, calfun = \"raking\") pst_est_rake <- svymean(~Petal.Length, design = pst_design_rake) pst_est_rake #>               mean     SE #> Petal.Length 3.764 0.0635"},{"path":"https://yangjasp.github.io/optimall/articles/Multiwave-Estimation.html","id":"wave-specific-conditional-probabilities","dir":"Articles","previous_headings":"How to implement each strategy with optimall and survey","what":"2. Wave-specific conditional probabilities","title":"Estimation in Two-phase, Multi-wave sampling","text":"wave-specific conditional probabilities approach complicated requires computation denominator (\\(\\ref{eq:eq6}\\)), variance estimation involves pairwise element inclusion probabilities (\\(\\ref{eq:eq7}\\)). Still, possible obtain estimates asymptotic standard errors approach optimall Survey. can compute denominator (\\(\\ref{eq:eq6}\\)) : can compute estimate sample mean twophase() long every stratum sampled every wave: strata sampled wave, can still compute estimator mean (Equation \\(\\ref{eq:eq6}\\)) hand: Finally, can estimate standard error directly evaluating Equation (\\(\\ref{eq:eq7}\\)). Rather computing variance entirely hand final steps , another option feed pairwise sampling probability matrix survey. lead answer. computation Phase 2 variance Equation (\\(\\ref{eq:eq7}\\)) can bit arduous, stratum sampled least twice wave, result closely approximated lines survey package. can done stratifying original strata sampling wave phase 2-specific call svydesign:","code":"## Find denominator from eq. 6 for each wave, species denom_data <- survey_data %>%   dplyr::select(Species, wave, sampling_prob) %>%   dplyr::distinct() %>%   dplyr::filter(!is.na(wave)) %>%   arrange(Species, wave) %>%   group_by(Species) %>%   dplyr::mutate(denom = ifelse(wave == 1, sampling_prob,                                 sampling_prob * cumprod(1 - lag(sampling_prob, default = 0))))%>%   ungroup()  ## Merge back with original dataframe, attaching the denominator to each obs. survey_data <- survey_data %>%   dplyr::left_join(dplyr::select(denom_data, Species, wave, denom),                     by = c(\"Species\",\"wave\")) cp_design <- twophase(id = list(~id, ~id), strata = list(NULL, ~Species),                       subset = ~as.logical(sampled_phase2),                       data = survey_data, probs = list(NULL, ~denom))  cp_est <- svymean(~Petal.Length, design = cp_design) cp_est[1] #> Petal.Length  #>     3.999145 phase2_data <- survey_data[survey_data$sampled_phase2 == 1,]  # Weight observations by denominator from equation 6 phase2_data$weighted_obs <- phase2_data$Petal.Length/phase2_data$denom  # Determine number of waves each stratum was sampled in   sampled_waves <- denom_data[denom_data$sampling_prob > 0,] n_waves_sampled <- table(sampled_waves$Species)  # Compute estimate for total in equation 6 total_est <- (sum(phase2_data[phase2_data$Species == \"setosa\",                               \"weighted_obs\"])/ n_waves_sampled[\"setosa\"] +                 sum(phase2_data[phase2_data$Species == \"virginica\",                                 \"weighted_obs\"])/n_waves_sampled[\"virginica\"]+                 sum(phase2_data[phase2_data$Species == \"versicolor\",                                 \"weighted_obs\"])/n_waves_sampled[\"versicolor\"]) names(total_est) <- \"Petal.Length\"  # Finally, compute the mean cp_est <- total_est/nrow(survey_data)  cp_est # this matches svymean() output above if all strata sampled in all waves #> Petal.Length  #>     3.709761 ### Combine design dataframes for waves 1-3.  design_all_waves <- dplyr::bind_rows(cbind(phase2_wave = 1,                                             get_mw(Survey, 2, 1, \"design\")),                                      cbind(phase2_wave = 2,                                             get_mw(Survey, 2, 2, \"design\")),                                      cbind(phase2_wave = 3,                                             get_mw(Survey, 2, 3, \"design\"))) %>%   dplyr::mutate(n_to_sample = dplyr::coalesce(n_to_sample, stratum_size),                 nsample_prior = ifelse(is.na(nsample_prior),                                         0 , nsample_prior))  ### ### Now add three columns to design: prob of two obs being sampled in a given ### wave, prob of neither being sampled in given wave, or prob of only (specific)  ### one being sampled in given wave design_all_waves <- design_all_waves |>   dplyr::mutate(both_pp = n_to_sample/(npop - nsample_prior)*                   (n_to_sample-1)/(npop - nsample_prior - 1), #n/N*(n-1)/(N-1)                 onlyone_pp = n_to_sample/(npop - nsample_prior)*                   (npop- nsample_prior- n_to_sample)/(npop - nsample_prior - 1),                 neither_pp =                    (npop- nsample_prior- n_to_sample)/(npop - nsample_prior)*                   (npop- nsample_prior- n_to_sample-1)/(npop - nsample_prior - 1),                 single_prob = n_to_sample/(npop - nsample_prior))   ### One row for each stratum design_all_waves_wide <- design_all_waves %>%   dplyr::select(phase2_wave, strata, both_pp, onlyone_pp, neither_pp, single_prob) %>%   tidyr::pivot_wider(names_from = phase2_wave, values_from = c(both_pp, onlyone_pp,                                                                neither_pp, single_prob))  ### Compute pairwise probability of inclusion and variance contribution ### for each pair of Phase 2 samples phase2_ids <- dplyr::filter(survey_data, sampled_phase2 == 1)$id pairwise_df <- expand.grid(\"id1\" = phase2_ids, \"id2\" = phase2_ids) %>%   dplyr::left_join(dplyr::select(survey_data, id, \"Species1\" = Species,                                  \"wave1\" = wave,                                  \"denom1\" = denom,                                  \"Petal.Length1\" = Petal.Length),                    by = c(\"id1\" = \"id\")) %>%   dplyr::left_join(dplyr::select(survey_data, id, \"Species2\" = Species,                                  \"wave2\" = wave,                                  \"denom2\" = denom,                                  \"Petal.Length2\" = Petal.Length),                    by = c(\"id2\" = \"id\")) %>%   dplyr::left_join(design_all_waves_wide, by = c(\"Species1\" = \"strata\")) %>%   dplyr::mutate(pairwise_prob =                   case_when(id1 == id2 ~ denom1,                             Species1 != Species2 ~ denom1*denom2,                             wave1 == 1 & wave2 == 1 ~ both_pp_1,                             wave1 == 2 & wave2 == 2 ~ neither_pp_1*both_pp_2,                             wave1 == 3 & wave2 == 3 ~ neither_pp_1*neither_pp_2*both_pp_3,                             TRUE ~ denom1*denom2),                 phase2_variance_contribution = (1-denom1*denom2/pairwise_prob)*                   Petal.Length1*Petal.Length2/(denom1*denom2)   )  phase2_variance_est <- sum(pairwise_df$phase2_variance_contribution)/nrow(phase1_data)^2/3^2  ## ## Final variance estimator combines the phase 2 variance that we just calculated with ## phase 1 variance (which was already calculated in post-stratified estimator)  ### Extract phase 1 variance estimate from pst_est phase1_variance_est <- attr(SE(pst_est), \"phases\")$phase1[1]  ### Estimate variance with two-phase() cp_est_ase <- sqrt(phase2_variance_est + phase1_variance_est) cp_est_ase #> [1] 0.07430421 pairwise_probs <- matrix(pairwise_df$pairwise_prob,                          ncol = length(phase2_ids), byrow = TRUE)  phase2_data <- survey_data[survey_data$sampled_phase2 == 1,] cp_design_phase2 <- svydesign(id = ~id,                               data = phase2_data, probs = ~denom,                               pps = ppsmat(pairwise_probs))  phase2_variance_est <- (SE(svytotal(~Petal.Length, design = cp_design_phase2))/nrow(phase1_data)/3)^2  cp_est_ase <- sqrt(phase2_variance_est + phase1_variance_est) cp_est_ase #>            [,1] #> [1,] 0.07430421 phase2_data <- survey_data[survey_data$sampled_phase2 == 1,] phase2_data$strata_int <- paste0(phase2_data$Species, \".\", phase2_data$wave) svydesign_phase2 <- svydesign(data = phase2_data,                               ids = ~id,                               strata = ~strata_int,                               probs = ~denom)  estimate_approx <- svytotal(~Petal.Length, svydesign_phase2)/nrow(phase1_data)/3 estimate_approx[1] #> Petal.Length  #>     3.553907 variance_approx <- sqrt(phase1_variance_est + (SE(estimate_approx)/nrow(phase1_data)/3)^2) variance_approx #>              Petal.Length #> Petal.Length   0.07500754"},{"path":"https://yangjasp.github.io/optimall/articles/Multiwave-Estimation.html","id":"comparing-estimation-methods-through-simulation","dir":"Articles","previous_headings":"","what":"Comparing estimation methods through simulation","title":"Estimation in Two-phase, Multi-wave sampling","text":"compare performance estimators, perform two-phase, multiwave sampling repeatedly simulated phase 2 datasets form large iris dataset previous section. tables show results estimation strategy. use abbreviations ASE: asymptotic standard error estimated survey, ESE: empirical standard error, RMSE: root mean square error. Median 2,000 simulations reported point estimate ASE. code run simulations available Github . n = 80 per wave: n = 50 per wave: n = 20 per wave:  ## References * Breslow, N. E., Lumley, T., Ballantyne, C. M., Chambless, L. E., & Kulich, M. (2009). Improved Horvitz–Thompson estimation model parameters two-phase stratified samples: applications epidemiology. Statistics biosciences, 1, 32-49. * Chen, T., & Lumley, T. (2022). Optimal sampling design‐based estimators regression models. Statistics medicine, 41(8), 1482-1497. * Holt, D., & Smith, T. F. (1979). Post stratification. Journal Royal Statistical Society Series : Statistics Society, 142(1), 33-46. * Lumley, T., Shaw, P. ., & Dai, J. Y. (2011). Connections survey calibration estimators semiparametric models incomplete data. International Statistical Review, 79(2), 200-220. * McIsaac MA, Cook RJ. Adaptive sampling two‐phase designs: biomarker study progression arthritis. Statistics Medicine. 2015 Sep 20;34(21):2899-912. * Särndal CE, Swensson B, Wretman J (2003). Model Assisted Survey Sampling. Springer- Verlag Science & Business Media * Shepherd , Han K, Chen T, Bian , Pugh S, Duda S, Lumley T, Heerman WJ, Shaw PA (2023). “Multiwave validation sampling error-prone electronic health records.” Biometrics, 79(3), 2649–2663. doi:10.1111/biom.13713. * Valliant R (1993). “Poststratification conditional variance estimation.” Journal American Statistical Association, 88(421), 89–96. * Wright, T. simple method exact optimal sample allocation stratification mixed constraint patterns.2014; Statistics, 07.","code":""},{"path":"https://yangjasp.github.io/optimall/articles/Multiwave-Estimation.html","id":"appendix","dir":"Articles","previous_headings":"","what":"Appendix","title":"Estimation in Two-phase, Multi-wave sampling","text":"code generate example iris dataset optimall provided :","code":"##### ## Generate data ##### set.seed(1) n <- c(rmultinom(1, 1000, c(1/3, 1/3, 1/3))) col1 <- c(rep(\"setosa\", times = n[1]),           rep(\"versicolor\", times = n[2]),           rep(\"virginica\", times = n[3])) pl <- c(rnorm(n[1], 1.462, 0.432),         rnorm(n[2], 4.260, 0.470),         rnorm(n[3], 5.552, 0.552)) sl <- c(rnorm(n[1], pl[1:n[1]] * 3.35, 0.341),         rnorm(n[2], pl[(n[1]+1):(n[1]+n[2])] * 1.32, 0.366),         rnorm(n[3],  pl[(n[2]+1):1000] * 1.14, 0.302)) full_data <- data.frame(\"id\" = 1:1000,                         \"Species\" = as.factor(col1),                         \"Sepal.Length\" = sl,                         \"Petal.Length\" = pl) phase1_data <- full_data[,-4]  #### ## Multiwave object setup ####  Survey <- multiwave(phases = 2, waves = c(1, 3),                     phase1 = phase1_data)  set_mw(Survey, phase = 2, slot = \"metadata\") <- list(id = \"id\",                                                      strata = \"Species\",                                                      design_strata = \"strata\",                                                      include_probs = TRUE)  #### ## Wave 1 ####  ### Allocation: X-allocate with Phase 1 sepal length Survey <- apply_multiwave(Survey, phase = 2, wave = 1,                           fun = \"optimum_allocation\",                           y = \"Sepal.Length\",                           nsample = 50, method = \"Neyman\")  # get_mw(Survey, phase = 2, wave = 1, slot =\"design\")  ### Select samples  Survey <- apply_multiwave(Survey, phase = 2, wave = 1,                           fun = \"sample_strata\",                            n_allocated = \"stratum_size\",                           probs = ~stratum_size/npop)  ### \"Collect\" data set_mw(Survey, phase = 2, wave = 1, slot = \"sampled_data\") <-    full_data[full_data$id %in% get_mw(Survey, phase = 2, wave = 1,                                      slot = \"samples\")$ids,              c(\"id\", \"Petal.Length\")]  Survey <- merge_samples(Survey, phase = 2, wave = 1)  #### ## Wave 2 ####  ### Allocation: Neyman allocation with already-collected phase 2 data. Survey <- apply_multiwave(Survey, phase = 2, wave = 2,                           fun = \"allocate_wave\",                           y = \"Petal.Length\",                           nsample = 50, allocation_method = \"Neyman\",                           already_sampled = \"sampled_phase2\")  # get_mw(phase = 2, wave = 2, slot = \"design\")  ### Select samples  Survey <- apply_multiwave(Survey, phase = 2, wave = 2,                           fun = \"sample_strata\",                            n_allocated = \"n_to_sample\",                           probs = ~n_to_sample/(npop - nsample_prior),                           already_sampled = \"sampled_phase2\")  ### \"Collect\" data set_mw(Survey, phase = 2, wave = 2, slot = \"sampled_data\") <-    full_data[full_data$id %in% get_mw(Survey, phase = 2, wave = 2,                                      slot = \"samples\")$ids,              c(\"id\", \"Petal.Length\")] Survey <- merge_samples(Survey, phase = 2, wave = 2)  #### ## Wave 3 ####  ### Allocation: Neyman allocation with already-collected phase 2 data. Survey <- apply_multiwave(Survey, phase = 2, wave = 3,                           fun = \"allocate_wave\",                           y = \"Petal.Length\",                           nsample = 50, allocation_method = \"Neyman\",                           already_sampled = \"sampled_phase2\")  # get_mw(phase = 2, wave = 3, slot = \"design\")  ### Select samples  Survey <- apply_multiwave(Survey, phase = 2, wave = 3,                           fun = \"sample_strata\",                            n_allocated = \"n_to_sample\",                           probs = ~n_to_sample/(npop - nsample_prior),                           already_sampled = \"sampled_phase2\")  ### \"Collect\" data set_mw(Survey, phase = 2, wave = 3, slot = \"sampled_data\") <-    full_data[full_data$id %in% get_mw(Survey, phase = 2, wave = 3,                                      slot = \"samples\")$ids,              c(\"id\", \"Petal.Length\")] Survey <- merge_samples(Survey, phase = 2, wave = 3)  ### Final dataset for analysis survey_data <- get_mw(Survey, phase = 2, wave = 3, slot = \"data\")  ### Clean up for printing survey_data <- survey_data[,c(\"id\", \"Species\", \"Sepal.Length\",                                \"Petal.Length\", \"sampled_phase2\",                               \"sampled_wave2.1\", \"sampled_wave2.2\",                               \"sampled_wave2.3\", \"sampling_prob\")] survey_data <- survey_data[order(-survey_data$sampled_phase2,                                   survey_data$id), , drop = FALSE] %>%   dplyr::mutate(wave = case_when(sampled_wave2.1 == 1 ~ 1,                                  sampled_wave2.2 == 1 ~ 2,                                  sampled_wave2.3 == 1 ~ 3))"},{"path":"https://yangjasp.github.io/optimall/articles/Multiwave-Object.html","id":"overview","dir":"Articles","previous_headings":"","what":"Overview","title":"Multiwave Object","text":"base functions optimall allow users efficiently determine optimum allocation, select samples, split strata design multi-wave stratified sampling survey. Despite features, efficient sampling workflow R still requires user manually organize many moving parts process including design data, list samples, data extracted samples, merged data wave. sampling design involves many waves, parts can difficult keep track may prone errors. Even , may difficult go back reproduce results end long sampling process. vignette describes addition optimall called multiwave object, stores metadata, design, samples, merged data step multi-wave sampling process accessible format. optional user use, offers advantages automatic organization, efficient compatibility functions optimall, option summary sampling design printed point. recommended user thoroughly reads introductory package vignette titled “Using Optimall” reading vignette. addition contributes towards optimall's goal tool streamline often cumbersome aspects multi-wave sampling workflow.","code":""},{"path":"https://yangjasp.github.io/optimall/articles/Multiwave-Object.html","id":"format","dir":"Articles","previous_headings":"","what":"Format","title":"Multiwave Object","text":"multiwave object uses S4 class system, makes slightly complicated work R. Fortunately, potential complications dealt package design unseen user. user see:  multiwave object contains three S4 classes: Wave: Wave class (green figure ) holds metadata, design, samples, sampled data, data single wave multi-wave sampling. Phase: Phase class (orange figure ) holds metadata list Wave objects phase. Multiwave: Multiwave class (dark blue figure ) contains metadata list Phase objects. holds entire sampling design class user interact . light blue objects figure represent slots hold survey information directly: Metadata: metadata slot holds initially empty list. Relevant information can added named elements, including titles, data dictionaries, arguments optimall functions. Design: design slot holds data frame specifying sampling design current wave. order used sample_strata(), must contain least one column holding strata names one column holding number samples selected strata. typically output optimum_allocation() allocate_wave(). Samples: samples slot holds list containing : ids: vector sample ids selected specific wave. probs: Optionally, numeric vector sampling probabilities corresponding id ids. Sampled Data: sampled data slot contains data frame holding data collected specific wave. Data: data slot contains data frame full data gets updated wave (phase phase 1). typically sampled data merged (full) data previous wave. way, data data slot study’s ultimate sampling wave full study data can used analysis survey package.","code":""},{"path":"https://yangjasp.github.io/optimall/articles/Multiwave-Object.html","id":"getting-started-with-the-multiwave-object","dir":"Articles","previous_headings":"","what":"Getting Started with the Multiwave Object","title":"Multiwave Object","text":"Working multiwave object requires knowledge functions. section describes initialize object, access write slots , deploy useful features. demonstrated context two-phase, multiwave sampling design used package vignette. multiwave object initialized function multiwave(): now object can hold information two-phase survey second phase conducted three waves. Note length ’waves‘ argument must match number phases. Phase 1 almost always one wave.","code":"MySurvey <- multiwave(phases = 2, waves = c(1,3))"},{"path":"https://yangjasp.github.io/optimall/articles/Multiwave-Object.html","id":"access-and-write-slots","dir":"Articles","previous_headings":"Getting Started with the Multiwave Object","what":"Access and Write slots","title":"Multiwave Object","text":"standard S4 object R, components multiwave object stored slots. access write slots multiwave object, user use @ $: overly complicated potentially unstable. Instead, slot multiwave object can accessed using function get_mw(), requires specification phase, wave, slot name: Similarly, slot can written using set_mw(): #write overall metadata Note calls get data phase 1 require wave specified, since phase 1 consists one wave. Let’s suppose phase 1 data collected. can add phase 1 data slot object include relevant metadata:","code":"#To access overall metadata MySurvey@metadata #> list()  #To write overall metadata. We may want to include a title. MySurvey@metadata <- list(title = \"Maternal Weight Survey\")  #To access Phase 2 metadata MySurvey@phases$phase2@metadata #> list()  #To access Phase 2, Wave 2 design MySurvey@phases$phase2@waves$wave2@design #> data frame with 0 columns and 0 rows #To access overall metadata get_mw(MySurvey, phase = NA, slot = \"metadata\") #> $title #> [1] \"Maternal Weight Survey\"  #To access Phase 2 metadata get_mw(MySurvey, phase = 2, slot = \"metadata\") #> list()  #To access Phase 2, Wave 2 design get_mw(MySurvey, phase = 2, wave = 2, slot = \"design\") #> data frame with 0 columns and 0 rows set_mw(MySurvey, phase = NA, slot = \"metadata\") <- list(title = \"Maternal Weight Survey\") head(phase1) #>                    new_strata old_strata   id mat_weight_est  race diabetes #> 1  Black.MWC_est_(9.75,15.06]      Black 5586      12.176368 Black        0 #> 2  Black.MWC_est_(9.75,15.06]      Black 7322      11.774911 Black        0 #> 3  Black.MWC_est_(9.75,15.06]      Black 3602      10.649515 Black        0 #> 4  Black.MWC_est_(9.75,15.06]      Black 2734      12.026532 Black        0 #> 5 Black.MWC_est_(15.06,38.46]      Black  581      16.828686 Black        0 #> 6 Black.MWC_est_[-30.21,9.75]      Black 6531       9.163454 Black        1 #>   obesity #> 1       0 #> 2       0 #> 3       0 #> 4       1 #> 5       0 #> 6       0  set_mw(MySurvey, phase = 1, slot = \"data\") <- phase1  #Make Phase 1 data dict phase1_data_dictionary <- data.frame(   \"Variable\" = c( \"id\", \"race\", \"mat_weight_est\", \"diabetes\", \"obesity\"),   \"Description\" = c(\"unique identifier\",                      \"race of mother\",                     \"error-prone estimate of maternal weight change                      during pregnancy\",                     \"1/0 indicator for diabetes in the mother during                      pregnancy\",                     \"1/0 indicator for childhood obesity in child\"))  head(phase1_data_dictionary) #>         Variable #> 1             id #> 2           race #> 3 mat_weight_est #> 4       diabetes #> 5        obesity #>                                                                             Description #> 1                                                                     unique identifier #> 2                                                                        race of mother #> 3 error-prone estimate of maternal weight change \\n                    during pregnancy #> 4       1/0 indicator for diabetes in the mother during \\n                    pregnancy #> 5                                          1/0 indicator for childhood obesity in child  set_mw(MySurvey, phase = 1, slot = \"metadata\") <- list(data_dict = phase1_data_dictionary)"},{"path":"https://yangjasp.github.io/optimall/articles/Multiwave-Object.html","id":"view-summary-diagram-of-survey","dir":"Articles","previous_headings":"Getting Started with the Multiwave Object","what":"View Summary Diagram of Survey","title":"Multiwave Object","text":"point multi-wave sampling workflow, optimall allows users view diagram structure survey multiwave_diagram():  Notice title survey, “Maternal Weight Survey”, found overall survey metadata boxes colored based whether filled yet. Slots filled blue contain short description contents. function enables users track progress multiwave sampling survey.","code":"multiwave_diagram(MySurvey)"},{"path":"https://yangjasp.github.io/optimall/articles/Multiwave-Object.html","id":"call-optimall-functions-with-fewer-arguments","dir":"Articles","previous_headings":"Getting Started with the Multiwave Object","what":"Call optimall functions with fewer arguments","title":"Multiwave Object","text":"Another advantage multiwave object primary functions optimall optimum_allocation(), allocate_wave(), sample_strata() can called object using function apply_multiwave(), apply_multiwave() function takes standard arguments function well phase wave, used determine input dataframe(s) slot object output placed. arguments, including names columns (tend repetitive used without multiwave object framework), specified metadata, function find , allowing calls function much simpler. recommended users gain familiarity basic uses functions dataframes using multiwave objects. working multiwave object, new function called merge_samples() also becomes available. allows users quickly efficiently merge sampled data previous wave’s data. demonstrate, return example sampling sepal width iris dataset adaptive, multi-wave design. Suppose collected data sepal length, petal width, petal length 150 iris plants phase 1, yet collected ”expensive” sepal width variable. can start placing data appropriate slot multiwave object: Now want begin first wave sampling sepal width phase 2. Since expect sepal length correlated variable interest, decide x-allocate first wave samples using integer-valued Neyman allocation inexpensive sepal length variable. Since working multiwave object framework, can use apply_multiwave() apply optimum_allocation() function: Since \"strata\" \"Species\" every wave, may instead move argument phase metadata don’t repetitively specify argument every function call: Now longer specify strata function call: absence specific strata argument, apply_multiwave() turns wave, phase, overall metadata look missing argument. case, finds strata = \"Species\" phase metadata. specifying phase wave function call, telling optimum_allocation() use recent version data (full data previous wave, case, phase 1 data) input output results corresponding slot specified wave. , calls apply_multiwave() output updated multiwave object results optimum_allocation() phase 2, wave 1 \"design\" slot: allocate_wave() function can applied multiwave objects manner demonstrated following examples section. functions used specify ”design” data frame (manually created design data frame placed ”design” slot implement different allocation strategy), can use apply_multiwave() apply sample_strata() select ids sample given sampling wave: Note specify data design_data standard version sample_strata() extracted multiwave object using phase wave arguments. also specify strata argument available phase metadata. result call apply_multiwave() updated IrisSurvey vector ids sample inclusion probabilities “samples” slot: working multiwave object, new function called merge_samples() also becomes available. function allows users quickly efficiently merge sampled data previous wave’s data. Suppose collected sepal width 30 plant ids placed data “sampled_data” slot phase 2, wave 1 IrisSurvey: can call merge_samples() smoothly merge sampled_data current wave (full) data previous wave place output data slot current wave: \"data\" slot phase 2, wave 1, now updated dataframe phase 1 data sepal width column sampled data selected ids NA values rest plants. also new column called \"sampled_phase2\" holds indicator samples sampled phase 2 thus far, new column called “sampled_wave2.1” holds indicator samples sampled wave1 phase 2, column inclusion probabilities specified include_probs = TRUE: Calls merge_samples() later waves phase 2 update phase sampled indicator time. sample_strata function use column ensure units sampled previous waves selected . utility merge_samples() apply_multiwave() demonstrated .","code":"# Initialize Multiwave IrisSurvey <- multiwave(phases = 2, waves = c(1,3))  # Add id column to iris dataset iris <- cbind(datasets::iris, id = 1:150)  # To place iris data in Phase 1 set_mw(IrisSurvey, phase = 1, slot = \"data\") <-     subset(iris, select = -Sepal.Width) IrisSurvey <- apply_multiwave(IrisSurvey, phase = 2, wave = 1,                             fun = \"optimum_allocation\",                             strata = \"Species\", y = \"Sepal.Length\",                             nsample = 30, method = \"WrightII\") set_mw(IrisSurvey, phase = 2, slot = \"metadata\") <-   list(strata = \"Species\") IrisSurvey <- apply_multiwave(IrisSurvey, phase = 2, wave = 1,                             fun = \"optimum_allocation\",                             y = \"Sepal.Length\",                             nsample = 30, method = \"WrightII\") get_mw(IrisSurvey, phase = 2, wave = 1, slot = \"design\") #>       strata npop   sd  n_sd stratum_fraction stratum_size #> 1     setosa   50 0.35 17.62             0.23            7 #> 2 versicolor   50 0.52 25.81             0.33           10 #> 3  virginica   50 0.64 31.79             0.43           13 IrisSurvey <- apply_multiwave(IrisSurvey, phase = 2, wave = 1,                             fun = \"sample_strata\", id = \"id\",                             design_strata = \"strata\",                             n_allocated = \"stratum_size\",                             probs = \"stratum_fraction\") get_mw(IrisSurvey, phase = 2, wave = 1, slot = \"samples\") #> $ids #>  [1]  11  21  25  26  27  28  33  54  57  67  68  69  75  80  85  89  98 103 106 #> [20] 113 115 129 131 132 134 136 137 140 141 144 #>  #> $probs #>  [1] 0.23 0.23 0.23 0.23 0.23 0.23 0.23 0.33 0.33 0.33 0.33 0.33 0.33 0.33 0.33 #> [16] 0.33 0.33 0.43 0.43 0.43 0.43 0.43 0.43 0.43 0.43 0.43 0.43 0.43 0.43 0.43 set_mw(IrisSurvey, phase = 2, wave = 1, slot = \"sampled_data\") <-   iris[iris$id %in% get_mw(IrisSurvey,                              phase = 2,                              wave = 1,                              slot = \"samples\")$ids,        c(\"id\", \"Sepal.Width\")] IrisSurvey <- merge_samples(IrisSurvey, phase = 2, wave = 1,                           id = \"id\", include_probs = TRUE) head(get_mw(IrisSurvey, phase = 2, wave = 1, slot = \"data\")) #>   Sepal.Length Petal.Length Petal.Width Species id Sepal.Width sampled_phase2 #> 1          5.1          1.4         0.2  setosa  1          NA              0 #> 2          4.9          1.4         0.2  setosa  2          NA              0 #> 3          4.7          1.3         0.2  setosa  3          NA              0 #> 4          4.6          1.5         0.2  setosa  4          NA              0 #> 5          5.0          1.4         0.2  setosa  5          NA              0 #> 6          5.4          1.7         0.4  setosa  6          NA              0 #>   sampled_wave2.1 sampling_prob #> 1               0            NA #> 2               0            NA #> 3               0            NA #> 4               0            NA #> 5               0            NA #> 6               0            NA"},{"path":"https://yangjasp.github.io/optimall/articles/Multiwave-Object.html","id":"example-wave-workflow-using-optimall-with-a-multiwave-object","dir":"Articles","previous_headings":"Getting Started with the Multiwave Object","what":"Example Wave Workflow Using optimall with a Multiwave Object","title":"Multiwave Object","text":"section, demonstrate example multiwave object can useful adaptive multi-wave sampling workflow. example, create execute Wave 1 Phase 2 sample. first step Phase 2, Wave 1 specify metadata phase wave. Note can useful specify title, description, function arguments, anything else relevant survey metadata, nothing required specified. function arguments found metadata, must instead specified call apply_multiwave(). example choose specify description function arguments wave metadata: metadata specified, next step specify wave 1 survey design. allocate first 250 samples using x-allocation error-prone phase 1 maternal weight change estimates design variable. apply_multiwave() optimum_allocation() functions make straightforward: can use design randomly select ids sample previous wave (case overall Phase 1 data) using apply_multiwave() apply function sample_strata() multiwave object. applied object class “Multiwave”, sample_strata() find \"data\" \"design_data\" object look wave, phase, overall metadata arguments sample_strata() provided call. return multiwave object vector ids sample \"samples\" slot specified wave. can use sample ids sample Phase 2, Wave 1 data MatWgt_Sim, holds (hypothetically unknown) mat_weight_true variable: , can use function merge_samples() merge sampled data (250 rows data sampled wave 1 phase 2) just collected full dataframe (10,335 rows data sampled phase 1). function generates dataframe \"data\" slot specified wave using \"sampled data\" data previous wave (Phase 1 data case). slots wave now filled! can check make sure everything done far looks good using multiwave_diagram():  ! Now sampled data can use estimate stratum standard deviations, can use allocate_wave() allocate samples optimally next wave. applied multiwave object using apply_multiwave(), allocate_wave() find data previous wave (now previous wave Wave 1 Phase 2) look function arguments allocate_wave() metadata. output placed \"design\" slot specified wave: Now design Wave 2 specified. can continue similar steps future waves!","code":"# Metadata for Phase 2 including description, # and column names to be used in function calls. # Note that each element name corresponds to at least one argument of a  # function that will be called later on in the multi-wave workflow. set_mw(MySurvey, phase = 2, slot = \"metadata\") <-    list(description = \"Phase 2 of Maternal Weight Survey in which we        seek to validate 750 samples across three waves.\",        strata = \"new_strata\", # strata column in data (used in multiple funcs)        id = \"id\", # name of id column (used in sample_strata and merge_samples)        y = \"mat_weight_true\", # col for which to minimize variance                                    # (used in optimum_allocation)        design_strata = \"strata\", # strata column in designs (used for sample_strata)        n_allocated = \"n_to_sample\" # n allocated to strata in designs                                     # (used for sample_strata)        )  # Then, metadata for Wave 1 of Phase 2  set_mw(MySurvey, phase = 2, wave = 1, slot = \"metadata\") <-    list(description = \"First wave of 250         sampled using proportional sampling\") #Design for Wave 1 MySurvey <- apply_multiwave(MySurvey, phase = 2, wave = 1,                            fun = \"optimum_allocation\",                            strata = \"new_strata\",                            y = \"mat_weight_est\",                            nsample = 250, method = \"Neyman\")  get_mw(MySurvey, phase = 2, wave = 1, slot = \"design\") #>                        strata npop   sd    n_sd stratum_fraction stratum_size #> 1 Black.MWC_est_(15.06,38.46]  628 3.63 2277.53             0.09           23 #> 2  Black.MWC_est_(9.75,15.06] 1154 1.46 1688.46             0.07           17 #> 3 Black.MWC_est_[-30.21,9.75]  745 4.09 3050.57             0.12           31 #> 4 Other.MWC_est_(15.06,30.94]  325 2.41  781.93             0.03            8 #> 5  Other.MWC_est_(9.75,15.06]  929 1.44 1334.35             0.05           13 #> 6  Other.MWC_est_[-5.39,9.75]  456 2.46 1121.03             0.04           11 #> 7 White.MWC_est_(15.06,51.69] 1631 3.51 5726.61             0.23           57 #> 8  White.MWC_est_(9.75,15.06] 3084 1.44 4453.92             0.18           45 #> 9 White.MWC_est_[-25.68,9.75] 1383 3.24 4485.44             0.18           45 # Get list of ids to sample using stratified random sampling  # without replacement set.seed(456) MySurvey <- apply_multiwave(MySurvey, phase = 2, wave = 1,                             fun = \"sample_strata\",                             strata = \"new_strata\",                             id = \"id\",                             wave2a = NULL, #No one has been sampled yet                             design_strata = \"strata\", #from design                             n_allocated = \"stratum_size\"                             ) # check that it worked  head(get_mw(MySurvey, phase = 2, wave = 1, slot = \"samples\")$ids) #> [1] 5702 3127 3267 3369 5449 3227 length(get_mw(MySurvey, phase = 2, wave = 1, slot = \"samples\")$ids) #> [1] 250  # But, notice that we had already specified most of the arguments to  # sample_strata in the phase metadata. So, we can get the same result # with a much shorter call to the function set.seed(456)  MySurvey <- apply_multiwave(MySurvey, phase = 2, wave = 1,                              fun = \"sample_strata\",                             n_allocated = \"stratum_size\")  ids_wave1 <- get_mw(MySurvey, phase = 2, wave = 1, slot = \"samples\")$ids  #Check that  it gives same results head(ids_wave1) #> [1] 5702 3127 3267 3369 5449 3227 length(ids_wave1) #> [1] 250 # We can use these ids to get the data: set_mw(MySurvey, phase = 2, wave = 1, slot = \"sampled_data\") <-    MatWgt_Sim[MatWgt_Sim$id %in% ids_wave1, c(\"id\", \"mat_weight_true\")] MySurvey <- apply_multiwave(MySurvey, phase = 2, wave = 1, fun = \"merge_samples\") multiwave_diagram(MySurvey) MySurvey <- apply_multiwave(MySurvey,                                      phase = 2,                                      wave = 2,                                      fun = \"allocate_wave\",                                     nsample = 250,                                     already_sampled = \"phase_sample_ind2\")  get_mw(MySurvey, phase = 2, wave = 2, slot = \"design\") #>                        strata npop nsample_optimal nsample_actual nsample_prior #> 1 Black.MWC_est_(15.06,38.46]  628              57             57            23 #> 2  Black.MWC_est_(9.75,15.06] 1154              34             34            17 #> 3 Black.MWC_est_[-30.21,9.75]  745              55             55            31 #> 4 Other.MWC_est_(15.06,30.94]  325              15             15             8 #> 5  Other.MWC_est_(9.75,15.06]  929              29             29            13 #> 6  Other.MWC_est_[-5.39,9.75]  456              18             18            11 #> 7 White.MWC_est_(15.06,51.69] 1631             104            104            57 #> 8  White.MWC_est_(9.75,15.06] 3084              97             97            45 #> 9 White.MWC_est_[-25.68,9.75] 1383              91             91            45 #>   n_to_sample   sd #> 1          34 4.67 #> 2          17 1.52 #> 3          24 3.80 #> 4           7 2.37 #> 5          16 1.61 #> 6           7 2.06 #> 7          47 3.29 #> 8          52 1.61 #> 9          46 3.37"},{"path":"https://yangjasp.github.io/optimall/articles/Multiwave-Object.html","id":"conclusion","dir":"Articles","previous_headings":"","what":"Conclusion","title":"Multiwave Object","text":"examples, see many benefits creation Multiwave object offers optimall.","code":""},{"path":"https://yangjasp.github.io/optimall/articles/optimall-vignette.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Using Optimall","text":"study population composed heterogeneous subpopulations, stratified random sampling techniques often employed obtain precise estimates population characteristics. Efficiently allocating samples strata method crucial step study design, especially sampling expensive. optimall offers collection functions designed streamline process optimum sample allocation, single wave adaptive, multi-wave approach. main functions allow users : Define, split, merge strata based values percentiles variables. Calculate optimum number samples allocate stratum given study order minimize variance target sample mean. Select specific IDs sample based stratified sampling design. Optimally allocate fixed number samples sampling wave based results prior wave. used together, functions can automate sampling workflow. vignette outline package features one one (moving simple complex), introduce theoretical framework behind functions, finally demonstrate can used collectively perform multi-wave sampling R. final section details use optimall_shiny() efficiently make decisions splitting strata.","code":""},{"path":"https://yangjasp.github.io/optimall/articles/optimall-vignette.html","id":"defining-and-refining-strata","dir":"Articles","previous_headings":"","what":"Defining and Refining Strata","title":"Using Optimall","text":"stratified sampling, strata typically defined values quantiles inexpensive variables available entire population. Given dataset one row per sampling unit least one column containing variable can used construct strata, optimall allows users easily define, split, merge strata. demonstrate simple process refining strata optimall, use iris dataset R package datasets. Suppose defined three strata based \"Species\", want split two three, setosa virginica, half based within-stratum median \"Sepal.Width\". optimall, can calling split_strata() function: Similarly, can merge strata using function merge_strata(): split_strata merge_strata() functions quite versatile. See function documentation information.","code":"library(optimall) library(datasets)  iris <- datasets::iris table(iris$Species) #>  #>     setosa versicolor  virginica  #>         50         50         50 iris2 <- split_strata(data = iris,                      strata = \"Species\",                      split = c(\"setosa\", \"virginica\"),                       split_var = \"Sepal.Width\",                      split_at = c(0.5), type = \"local quantile\") table(iris2$new_strata) #>  #>  setosa.Sepal.Width_(3.4,4.4]  setosa.Sepal.Width_[2.3,3.4]  #>                            22                            28  #>                    versicolor virginica.Sepal.Width_(3,3.8]  #>                            50                            17  #> virginica.Sepal.Width_[2.2,3]  #>                            33 iris3 <- merge_strata(data = iris,                      strata = \"Species\",                      merge = c(\"setosa\", \"versicolor\"),                       name = \"set_or_vers\") table(iris3$new_strata) #>  #> set_or_vers   virginica  #>         100          50"},{"path":"https://yangjasp.github.io/optimall/articles/optimall-vignette.html","id":"optimum-allocation","dir":"Articles","previous_headings":"","what":"Optimum Allocation","title":"Using Optimall","text":"Assuming per-unit sampling cost stratum \\(S_h\\), standard deviation variable interest within stratum, can estimated, Neyman (1934) presented following solution optimally allocate \\(n\\) samples among \\(H\\) strata order minimize variance sample mean: \\[n_h = n \\frac{N_hS_h}{\\sum_{=1}^H N_iS_i}.\\] formula known Neyman allocation one functions available optimall. Neyman allocation offers advantage outputting sampling fractions can later multiplied \\(n\\) taken \\(n\\) known. Neyman allocation strong theoretical backing, Wright (2014) points limitations make sub-optimal practice. Neyman require solution \\(n_h\\) integer, thus rarely . taking fraction sample practical, researchers forced stray theory rounding sample sizes ways always optimal. Closely related first issue, rounded results \\(n_h\\) guaranteed sum \\(n\\). clearly sub-optimal. Wright offers alternative algorithms solve optimal problem discrete allocation sums exactly \\(n\\), can also implemented optimall. Essentially, approaches use linear constraints optimize allocation samples space integer values. makes use within-stratum variance population stratum size generate priority values, turn dictate many samples taken stratum. learn specifics algorithms, see Wright (2014). optimall package allows users select Neyman allocation, Wright Algorithm , Wright Algorithm II method argument optimum_allocation() function. optimum_allocation() function defaults using Wright Algorithm II. algorithm requires least 2 samples taken stratum. optimall, stratum sampling sizes Wright algorithms also constrained \\(N_h\\), population stratum size, using methods constraints Wright details Algorithm III. example optimum_allocation() called optimally allocate 40 samples among \"Species\" iris dataset, minimizing variance \"Sepal.Width\" sample mean. dataframe holds \\(N_h\\) \\(sd_h\\) stratum instead data individual unit, can still use optimum_allocation():","code":"sampling_design <- optimum_allocation(data = iris, strata = \"Species\",                                        y = \"Sepal.Width\",                                       nsample = 40, method = \"WrightII\") sampling_design #>       strata npop   sd  n_sd stratum_fraction stratum_size #> 1     setosa   50 0.38 18.95             0.38           15 #> 2 versicolor   50 0.31 15.69             0.30           12 #> 3  virginica   50 0.32 16.12             0.32           13 iris_summary <- data.frame(strata = unique(iris$Species),                            size = c(50, 50, 50),                            sd = c(0.3791, 0.3138, 0.3225))  optimum_allocation(data = iris_summary, strata = \"strata\",                    sd_h = \"sd\", N_h = \"size\",                     nsample = 40, method = \"WrightII\") #>       strata npop   sd  n_sd stratum_fraction stratum_size #> 1     setosa   50 0.38 18.95             0.38           15 #> 2 versicolor   50 0.31 15.69             0.30           12 #> 3  virginica   50 0.32 16.12             0.32           13"},{"path":"https://yangjasp.github.io/optimall/articles/optimall-vignette.html","id":"selecting-ids-to-sample","dir":"Articles","previous_headings":"","what":"Selecting IDs to Sample","title":"Using Optimall","text":"number units sample per stratum specified dataframe, optimall can select IDs units sampled using simple random sampling within strata function sample_strata(): output sample_strata() input dataframe new column called \"sample_indicator\" holds binary indicator whether unit sampled specified wave: dataframe, can easily extract vector ids sample: Note design_data output optimum_allocation() example, practice can dataframe one row per stratum one column specifying stratum’s desired sample size. , method allocating samples strata can implemented sample_strata() long design dataframe specified simple random sampling within strata used.","code":"iris$id <- 1:150 set.seed(743)  iris <- sample_strata(data = iris, strata = \"Species\", id = \"id\",                                design_data = sampling_design, design_strata = \"strata\",                                n_allocated = \"stratum_size\") head(iris) #>   Sepal.Length Sepal.Width Petal.Length Petal.Width Species id sample_indicator #> 1          5.1         3.5          1.4         0.2  setosa  1                0 #> 2          4.9         3.0          1.4         0.2  setosa  2                0 #> 3          4.7         3.2          1.3         0.2  setosa  3                0 #> 4          4.6         3.1          1.5         0.2  setosa  4                1 #> 5          5.0         3.6          1.4         0.2  setosa  5                0 #> 6          5.4         3.9          1.7         0.4  setosa  6                1 ids_to_sample <- iris$id[iris$sample_indicator == 1] head(ids_to_sample) #> [1]  4  6  8 11 14 15 length(ids_to_sample) #> [1] 40"},{"path":"https://yangjasp.github.io/optimall/articles/optimall-vignette.html","id":"adaptive-multi-wave-sampling","dir":"Articles","previous_headings":"","what":"Adaptive, Multi-Wave Sampling","title":"Using Optimall","text":"measuring variables interest expensive difficult, can advantageous employ multi-phase design, cheaper variables collected entire population expensive variables collected subsamples selected adaptive, multi-wave sampling. approach, documented McIsaac Cook (2015), involves multiple waves sampling information prior waves used inform optimum sampling design subsequent ones. understanding Neyman Wright’s optimum allocation methods depend heavily standard deviation estimates variable interest, benefit multi-wave sampling clear see. Sample allocations based prior waves use updated estimates nuisance parameters incorporate data accumulated prior sampling waves. optimal sampling proportion updated end wave, update guides sampling next wave. phase II data accumulate, necessary within-strata SD estimates, thus estimated optimal sampling proportions, expected closer true value. design described McIsaac Cook, large phase-sample first taken measure inexpensive covariates /outcome. results phase define strata sampled non-optimally (proportional balanced sampling) measurement expensive variable phase-IIa. phase-IIa results used estimate standard deviation required optimally allocate next wave samples. process iterated desired sample size variable interest achieved. outline workflow, facilitated optimall:   optimall allows users input phase-data iteratively allocate samples subsequent waves function allocate_wave(). function runs integer-valued optimum_allocation() dataset according Wright’s Algorithm II, takes account previous sampling waves determine current wave samples allocated. simple example, suppose want allocate 40 samples minimize variance \"Sepal.Width\" iris dataset, 30 40 already sampled. assume strata still defined \"Species\", 16 first 30 samples taken virginica species, 7 setosa, 7 versicolor. Assuming 30 samples base within-stratum standard deviation estimates , can allocate next 10 samples using allocate_wave(): Notice case, \"nsample_optimal\" match \"nsample_actual\" every stratum outputted design dataframe. occurred oversampled virginica stratum wave 1, meaning optimum stratum sample size among 40 total samples smaller amount samples already taken group. oversampling occurs, allocate_wave() recalculates optimum allocation among non-oversampled strata uses result allocate specified number samples optimally possible. oversampling occurs, \"nsample_optimal\" match \"nsample_actual\" every stratum. Now can easily get 10 new ids sample using wave2_design design_data sample_strata(). Notice specify design_strata n_allocated default arguments column names allocate_wave() output:","code":"# Set up Wave 1 wave1_design <- data.frame(strata = c(\"setosa\",                                        \"virginica\",                                       \"versicolor\"),                            stratum_size = c(7, 16, 7))  # Collect Sepal.Width from only the 30 samples phase1_data <- subset(datasets::iris, select =  -Sepal.Width)  phase1_data$id <- 1:nrow(phase1_data) #Add id column  set.seed(234) phase1_data <- sample_strata(data = phase1_data,                                 strata = \"Species\", id = \"id\",                                design_data = wave1_design,                                design_strata = \"strata\",                                n_allocated = \"stratum_size\")  wave1_ids <- iris$id[phase1_data$sample_indicator == 1]  wave1_sampled_data <- iris[iris$id %in% wave1_ids, c(\"id\",\"Sepal.Width\")]  wave1_data <- merge(phase1_data, wave1_sampled_data, by = \"id\",                      no.dups =  TRUE, all.x = TRUE)  # We have our 30 samples table(is.na(wave1_data$Sepal.Width), wave1_data$Species) #>         #>         setosa versicolor virginica #>   FALSE      7          7        16 #>   TRUE      43         43        34  # Now, allocate the next 10: wave2_design <- allocate_wave(data = wave1_data,                               strata = \"Species\",                                y = \"Sepal.Width\",                               already_sampled = \"sample_indicator\",                               nsample = 10,                                detailed = TRUE)  wave2_design #>       strata npop nsample_optimal nsample_actual nsample_prior n_to_sample   sd #> 1     setosa   50              19             15             7           8 0.47 #> 2 versicolor   50              12              9             7           2 0.29 #> 3  virginica   50               9             16            16           0 0.24 # Run sample_strata wave2_data <- sample_strata(data = wave1_data, strata = \"Species\",                             id = \"id\", already_sampled = \"sample_indicator\",                             design_data = wave2_design)   # Extract the 10 ids to sample wave2_ids <- iris$id[wave2_data$sample_indicator == 1]  wave2_ids #>  [1]  8 15 22 24 26 32 40 47 57 68"},{"path":[]},{"path":"https://yangjasp.github.io/optimall/articles/optimall-vignette.html","id":"overview","dir":"Articles","previous_headings":"Examples: Using optimall to Determine Study Design and Sample Data","what":"Overview","title":"Using Optimall","text":"use simulated dataset MatWgt_Sim demonstrate functions optimall can used carry study design sampling tasks R. section includes three examples, build upon eachother design execution multi-wave survey: Example 1: Uses function split_strata() define refine strata. Example 2: Uses function sample_strata() randomly select units sampled based specified sampling design. Example 3: Demonstrates conduct adaptive, multi-wave sampling design uses optimal Neyman allocation scheme step allocate next wave across strata. dataset contains simulated data based real study association maternal weight gain pregnancy risk childhood obesity controlling number clinical demographic covariates. hypothetical example, study data obtained electronic health records, known error-prone variables interested available without manual chart review. perfect world, chart review used validate obtain necessary variables every observation sample, chart review expensive difficult task. Researchers determined reasonably afford validate 750 10,335 child-mother pairs. refer 10,335 phase 1 sample, error-prone observations , refer 750 phase II sample, designed using tools optimall package. simplicity, suppose want use 750 samples estimate true population mean maternal weight change pregnancy minimal variance. goal accomplished last example adaptive, multi-wave sampling design.","code":""},{"path":"https://yangjasp.github.io/optimall/articles/optimall-vignette.html","id":"data-set-up","dir":"Articles","previous_headings":"Examples: Using optimall to Determine Study Design and Sample Data","what":"Data Set Up","title":"Using Optimall","text":"simulated data used example included optimall. dataset MatWgt_Sim contains 10335 rows, one mother-child pair, 6 columns containing ID numbers covariates see : Three covariates, child race, diabetes, estimated maternal weight, inexpensive collect subjects, determining true maternal weight requires tedious validation process. full version simulated dataset contains true weight change 10335 mothers, may may relationship covariates. purpose examples, suppose access full dataset. Instead, must sample optimally estimate mean true maternal weight changes. phase-, assume 10335 mother-child pairs sampled inexpensive covariates. Accordingly, define phase 1 dataset 10335 x 5 every column full MatWgt_Sim data excluding expensive true weight change. examples follow, assume validated maternal weight variable mat_weight_true available phase 2 sampling.","code":"data(MatWgt_Sim, package = \"optimall\") head(MatWgt_Sim) #>     id mat_weight_est  race diabetes obesity mat_weight_true #> 1 7667      12.954711 Asian        0       0       10.768935 #> 2 8554       9.607124 Asian        0       1        8.892049 #> 3 6324      10.998284 Asian        0       0       12.075861 #> 4 8320      10.702210 Asian        0       0       10.887584 #> 5 8543       6.485988 Asian        1       0        7.331542 #> 6  127      13.338445 Asian        0       1       12.936826 # Get phase 1 data, remove mat_weight_true which we assume is unknown phase1 <- subset(MatWgt_Sim, select =  -mat_weight_true) dim(phase1) #> [1] 10335     5"},{"path":"https://yangjasp.github.io/optimall/articles/optimall-vignette.html","id":"example-1-defining-sample-strata","dir":"Articles","previous_headings":"Examples: Using optimall to Determine Study Design and Sample Data","what":"Example 1: Defining Sample Strata","title":"Using Optimall","text":"suspect true mean maternal weight change may vary inexpensive covariates phase 1 dataset, decide split population 9 non-overlapping strata. stratum defined unique combination race global percentile maternal weight gain (≤25th, 25th - 75th, >75th). can accomplish quickly optimall using split_strata() function. now phase1 data new column specifying strata defined.","code":"phase1$strata <- phase1$race #initialize a strata column first  # Merge the smallest race categories  phase1 <- merge_strata(data = phase1,                            strata = \"race\",                           merge = c(\"Other\",\"Asian\"),                           name = \"Other\")  phase1 <- split_strata(data = phase1, strata = \"new_strata\", split = NULL,                         split_var = \"mat_weight_est\",                         type = \"global quantile\",                         split_at = c(0.25,0.75),                        trunc = \"MWC_est\") # Trunc argument specifies how to refer to mat_weight_est in new strata names head(phase1) #>                   new_strata old_strata   id mat_weight_est diabetes obesity #> 1 Other.MWC_est_(9.75,15.06]      Other 7667      12.954711        0       0 #> 2 Other.MWC_est_[-5.39,9.75]      Other 8554       9.607124        0       1 #> 3 Other.MWC_est_(9.75,15.06]      Other 6324      10.998284        0       0 #> 4 Other.MWC_est_(9.75,15.06]      Other 8320      10.702210        0       0 #> 5 Other.MWC_est_[-5.39,9.75]      Other 8543       6.485988        1       0 #> 6 Other.MWC_est_(9.75,15.06]      Other  127      13.338445        0       1 #>   strata #> 1  Asian #> 2  Asian #> 3  Asian #> 4  Asian #> 5  Asian #> 6  Asian table(phase1$new_strata) # 9 strata #>  #> Black.MWC_est_(15.06,38.46]  Black.MWC_est_(9.75,15.06]  #>                         628                        1154  #> Black.MWC_est_[-30.21,9.75] Other.MWC_est_(15.06,30.94]  #>                         745                         325  #>  Other.MWC_est_(9.75,15.06]  Other.MWC_est_[-5.39,9.75]  #>                         929                         456  #> White.MWC_est_(15.06,51.69]  White.MWC_est_(9.75,15.06]  #>                        1631                        3084  #> White.MWC_est_[-25.68,9.75]  #>                        1383"},{"path":"https://yangjasp.github.io/optimall/articles/optimall-vignette.html","id":"example-2-create-an-initial-phase-2-subsample-phase-iia","dir":"Articles","previous_headings":"Examples: Using optimall to Determine Study Design and Sample Data","what":"Example 2: Create an Initial Phase 2 Subsample: Phase-IIa","title":"Using Optimall","text":"strata now defined inexpensive variables sampled phase-, ready begin auditing patient records validation true maternal weight changes. Without validated data define optimum phase-IIa sample allocation, decide use proportional stratified sampling first 250 750 audits. Conveniently, optimall can select random sample us sample_strata(). sample_strata() function requires input two dataframes, one containing stratum membership individual unit (data) second specifying sampling design (design_data). design_data dataframe must contain least two columns: design_strata: column holding strata names n_allocated: total \\(n\\) allocated stratum. example, want proportion samples randomly taken stratum reflect population proportion total 250 samples. can now call sample_strata() randomly draw specified number samples stratum. output phase1 dataframe extra column indicating units sampled. can extract ids sample based indicator. submit 250 ids validation. Hypothetically, involves hard work trained nurses, example involves lines code. notice units validated NA values new columns. use non-missing validated data inform optimum allocation future sampling waves.","code":"phase2a_design <- data.frame(   strata_name = names(table(phase1$new_strata)),    strata_prop = as.vector(table(phase1$new_strata))/10335,   strata_n = round(250.3*as.vector(table(phase1$new_strata))/10335)   ) # 250.3 to make sure 250 samples after rounding sum(phase2a_design$strata_n)  #> [1] 250 phase2a_design #>                   strata_name strata_prop strata_n #> 1 Black.MWC_est_(15.06,38.46]  0.06076439       15 #> 2  Black.MWC_est_(9.75,15.06]  0.11165941       28 #> 3 Black.MWC_est_[-30.21,9.75]  0.07208515       18 #> 4 Other.MWC_est_(15.06,30.94]  0.03144654        8 #> 5  Other.MWC_est_(9.75,15.06]  0.08988873       22 #> 6  Other.MWC_est_[-5.39,9.75]  0.04412192       11 #> 7 White.MWC_est_(15.06,51.69]  0.15781326       40 #> 8  White.MWC_est_(9.75,15.06]  0.29840348       75 #> 9 White.MWC_est_[-25.68,9.75]  0.13381713       33 phase1 <- sample_strata(data = phase1, strata = \"new_strata\",                          id = \"id\", design_data = phase2a_design,                          design_strata = \"strata_name\",                          n_allocated = \"strata_n\") ids_to_sample2a <- phase1[phase1$sample_indicator == 1,\"id\"] length(ids_to_sample2a) # 250 ids to sample #> [1] 250 phase2a_samples <- MatWgt_Sim[MatWgt_Sim$id %in% ids_to_sample2a,                                c(\"id\",\"mat_weight_true\")]  phase2a <- merge(phase1, phase2a_samples, by = \"id\",                  no.dups =  TRUE, all.x = TRUE) names(phase2a) #> [1] \"id\"               \"new_strata\"       \"old_strata\"       \"mat_weight_est\"   #> [5] \"diabetes\"         \"obesity\"          \"strata\"           \"sample_indicator\" #> [9] \"mat_weight_true\" table(is.na(phase2a$mat_weight_true))  #>  #> FALSE  TRUE  #>   250 10085"},{"path":"https://yangjasp.github.io/optimall/articles/optimall-vignette.html","id":"example-3-optimally-allocate-2nd-and-3rd-waves-of-phase-2-sample","dir":"Articles","previous_headings":"Examples: Using optimall to Determine Study Design and Sample Data","what":"Example 3: Optimally Allocate 2nd and 3rd Waves of Phase 2 Sample","title":"Using Optimall","text":"phase-IIa, allocated samples strata using proportional sampling rather optimum allocation prior samples true maternal weight change estimate within-stratum variances. Now completed first wave validation, can estimate variances thus use optimum allocation subsequent sampling waves. phase-IIb (wave 2), optimally allocate 250 samples, raising total number validated samples 500. allocate_wave() function makes step simple calculating optimum allocation 500 samples, determining many units already sampled previous waves (Phase-IIa case), allocating 250 samples current wave make difference. output design dataframe summarizing results stratum. Looking output allocate_wave(), notice optimum sample sizes next wave vary greatly strata, greater one. set detailed = TRUE, can also see optimum allocation 500 samples ignoring prior wave sizes column \"nsample_optimal\". column matches \"nsample_actual\" oversample strata phase-IIa. cases \"n_to_sample\" = 0 strata, may lucky. optimum sample size stratum smaller amount allocated previous waves (\"nsample_prior\"), say stratum oversampled. oversampling occurs, allocate_wave() “closes” oversampled strata re-allocates remaining samples optimally among open strata. circumstances, total sampling allocation longer optimal, optimall output optimal allocation non-oversampled strata next wave. Although don’t see evidence oversampling, results suggest strata relatively imbalanced. decide split largest stratum three similarly-sized strata along mat_weight_est using local quantile option split_strata(). strata now balanced size, can re-run allocate_wave() make new design dataframe sample_strata() use determine ids sample phase-IIb. can now get validated maternal weight changes 250 subjects. results , can move onto final wave.","code":"phase2b <- phase2a  # Add indicator for units that were already sampled phase2b$already_sampled <- ifelse(phase2b$id %in% ids_to_sample2a, 1, 0)  # Make design  phase2b_design <- allocate_wave(data = phase2b, strata = \"new_strata\",                              y = \"mat_weight_true\",                              already_sampled = \"already_sampled\",                               nsample = 250,                              detailed = TRUE) phase2b_design #>                        strata npop nsample_optimal nsample_actual nsample_prior #> 1 Black.MWC_est_(15.06,38.46]  628              46             46            15 #> 2  Black.MWC_est_(9.75,15.06] 1154              38             38            28 #> 3 Black.MWC_est_[-30.21,9.75]  745              52             52            18 #> 4 Other.MWC_est_(15.06,30.94]  325              12             12             8 #> 5  Other.MWC_est_(9.75,15.06]  929              34             34            22 #> 6  Other.MWC_est_[-5.39,9.75]  456              30             30            11 #> 7 White.MWC_est_(15.06,51.69] 1631              83             83            40 #> 8  White.MWC_est_(9.75,15.06] 3084             117            117            75 #> 9 White.MWC_est_[-25.68,9.75] 1383              88             88            33 #>   n_to_sample   sd #> 1          31 3.51 #> 2          10 1.58 #> 3          34 3.32 #> 4           4 1.75 #> 5          12 1.73 #> 6          19 3.18 #> 7          43 2.44 #> 8          42 1.80 #> 9          55 3.04 phase2b <- split_strata(data = phase2b,                          split = \"White.MWC_est_(9.75,15.06]\",                         strata = \"new_strata\",                          split_var = \"mat_weight_est\",                         type = \"local quantile\", split_at = c(1/3,2/3)) phase2b_design <- allocate_wave(data = phase2b,                               strata = \"new_strata\",                              y = \"mat_weight_true\",                              already_sampled = \"already_sampled\",                              nsample = 250) phase2b_design #>                                                     strata npop nsample_actual #> 1                              Black.MWC_est_(15.06,38.46]  628             49 #> 2                               Black.MWC_est_(9.75,15.06] 1154             40 #> 3                              Black.MWC_est_[-30.21,9.75]  745             55 #> 4                              Other.MWC_est_(15.06,30.94]  325             13 #> 5                               Other.MWC_est_(9.75,15.06]  929             35 #> 6                               Other.MWC_est_[-5.39,9.75]  456             32 #> 7                              White.MWC_est_(15.06,51.69] 1631             88 #> 8  White.MWC_est_(9.75,15.06].mat_weight_est_(11.44,12.99] 1028             29 #> 9  White.MWC_est_(9.75,15.06].mat_weight_est_(12.99,15.05] 1028             39 #> 10  White.MWC_est_(9.75,15.06].mat_weight_est_[9.75,11.44] 1028             28 #> 11                             White.MWC_est_[-25.68,9.75] 1383             92 #>    nsample_prior n_to_sample #> 1             15          34 #> 2             28          12 #> 3             18          37 #> 4              8           5 #> 5             22          13 #> 6             11          21 #> 7             40          48 #> 8             29           0 #> 9             21          18 #> 10            25           3 #> 11            33          59  # Extract IDs to sample ids_to_sample2b <- sample_strata(data = phase2b,                                   strata = \"new_strata\",                                   id = \"id\",                                   already_sampled = \"already_sampled\",                                   design_data = phase2b_design,                                  design_strata = \"strata\",                                   n_allocated = \"n_to_sample\") ids_to_sample2b <-    ids_to_sample2b[ids_to_sample2b$sample_indicator == 1,\"id\"] length(ids_to_sample2b) #> [1] 250 # Take samples from true data phase2b_samples <- MatWgt_Sim[MatWgt_Sim$id %in% ids_to_sample2b,                               c(\"id\",\"mat_weight_true\")]  # Merge extracted samples with our data. # Note we use dplyr's coalesce here to merge sampled mat_weight_true with  # the mat_weight_true solumn already present in phase2b, but manner of  # merging of samples may vary from project to project. # For simpler merges, see 'Multiwave Object' vignette.  phase2b <- merge(phase2b, phase2b_samples, by = \"id\",                   no.dups = TRUE, all.x = TRUE)  library(dplyr)  phase2b$mat_weight_true <-    dplyr::coalesce(phase2b$mat_weight_true.x,                   phase2b$mat_weight_true.y) phase2b <- subset(phase2b, select = -c(mat_weight_true.x,                                        mat_weight_true.y))  table(is.na(phase2b$mat_weight_true)) # All are NA besides already sampled. #>  #> FALSE  TRUE  #>   500  9835"},{"path":"https://yangjasp.github.io/optimall/articles/optimall-vignette.html","id":"phase-iic","dir":"Articles","previous_headings":"Examples: Using optimall to Determine Study Design and Sample Data","what":"Phase-IIc","title":"Using Optimall","text":"auditing 250 additional samples Phase-IIb, 250 left validate reach goal 750. combine learned previous waves phase-II optimally assign final 250 samples phase-IIc. Following steps phase-IIb, use allocate_wave() find optimum sample sizes stratum based estimates variance using previous samples. determine ids sample using sample_strata(). now validated 750 samples! example shows, quite moving parts keep track multi-wave sampling workflow. performing multi-wave sampling design, may also want consider using optimall's multiwave object organize visualize process. feature described detail package vignette titled “Multiwave Object”.","code":"phase2c <- phase2b  # Add indicator for units that were already sampled phase2c$already_sampled <- ifelse(phase2b$id %in% c(ids_to_sample2a,                                                     ids_to_sample2b),                                    1, 0)  # Make Design phase2c_design <- allocate_wave(data = phase2c, strata = \"new_strata\",                              y = \"mat_weight_true\",                              already_sampled = \"already_sampled\",                               nsample = 250,                              detailed = TRUE) phase2c_design #>                                                     strata npop nsample_optimal #> 1                              Black.MWC_est_(15.06,38.46]  628              60 #> 2                               Black.MWC_est_(9.75,15.06] 1154              56 #> 3                              Black.MWC_est_[-30.21,9.75]  745              99 #> 4                              Other.MWC_est_(15.06,30.94]  325              18 #> 5                               Other.MWC_est_(9.75,15.06]  929              50 #> 6                               Other.MWC_est_[-5.39,9.75]  456              35 #> 7                              White.MWC_est_(15.06,51.69] 1631             176 #> 8  White.MWC_est_(9.75,15.06].mat_weight_est_(11.44,12.99] 1028              38 #> 9  White.MWC_est_(9.75,15.06].mat_weight_est_(12.99,15.05] 1028              48 #> 10  White.MWC_est_(9.75,15.06].mat_weight_est_[9.75,11.44] 1028              37 #> 11                             White.MWC_est_[-25.68,9.75] 1383             133 #>    nsample_actual nsample_prior n_to_sample   sd #> 1              60            49          11 3.07 #> 2              56            40          16 1.56 #> 3              99            55          44 4.29 #> 4              18            13           5 1.83 #> 5              50            35          15 1.74 #> 6              35            32           3 2.47 #> 7             176            88          88 3.50 #> 8              38            29           9 1.20 #> 9              48            39           9 1.50 #> 10             37            28           9 1.16 #> 11            133            92          41 3.12  # Find IDs to sample ids_to_sample2c <- sample_strata(data = phase2c,                                   strata = \"new_strata\",                                   id = \"id\",                                   already_sampled = \"already_sampled\",                                   design_data = phase2c_design,                                  design_strata = \"strata\",                                   n_allocated = \"n_to_sample\") ids_to_sample2c <-    ids_to_sample2c[ids_to_sample2c$sample_indicator == 1,\"id\"] length(ids_to_sample2c) #> [1] 250  # Sample phase2c_samples <- MatWgt_Sim[MatWgt_Sim$id %in% ids_to_sample2c,                               c(\"id\",\"mat_weight_true\")]  # Add samples to phase2c dataset phase2c <- merge(phase2c, phase2c_samples, by = \"id\",                   no.dups = TRUE, all.x = TRUE) phase2c$mat_weight_true <-    dplyr::coalesce(phase2c$mat_weight_true.x,                   phase2c$mat_weight_true.y) phase2c <- subset(phase2c, select = -c(mat_weight_true.x,                                        mat_weight_true.y))"},{"path":"https://yangjasp.github.io/optimall/articles/optimall-vignette.html","id":"splitting-strata-efficiently-with-optimall_shiny","dir":"Articles","previous_headings":"","what":"Splitting Strata Efficiently with optimall_shiny()","title":"Using Optimall","text":"many cases, deciding strata split difficult task. split_strata() makes job easier, designed situations strata split values already decided user. Running iteratively experiment different splits possible yet tedious. time user updates input, parameters split_strata() function updated accordingly, resulting dataframe showing optimum allocation samples among new strata displayed. user satsfied set inputs, can confirm split underlying data updated. code used perform split also displayed. Note data Shiny App loaded file, thus separate data used optimall workflow. means user return R session make changes determined Shiny app. app, however, makes easy printing code perform confirmed changes, making R easy copying pasting. may update \"data\" argument. information optimall_shiny see package vignette titled “Splitting Strata Optimall Shiny”.","code":""},{"path":"https://yangjasp.github.io/optimall/articles/optimall-vignette.html","id":"references","dir":"Articles","previous_headings":"","what":"References","title":"Using Optimall","text":"McIsaac MA, Cook RJ. Adaptive sampling two‐phase designs: biomarker study progression arthritis. Statistics Medicine. 2015 Sep 20;34(21):2899-912. Wright, T. simple method exact optimal sample allocation stratification mixed constraint patterns.2014; Statistics, 07.","code":""},{"path":"https://yangjasp.github.io/optimall/articles/using-optimall_shiny.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Splitting Strata with Optimall Shiny","text":"function optimall_shiny(), located within package optimall, launches Shiny app allows users observe stratum sizes, standard deviations, optimum allocations react different stratum splits. vignette demonstrates use application.","code":""},{"path":"https://yangjasp.github.io/optimall/articles/using-optimall_shiny.html","id":"uploading-data","dir":"Articles","previous_headings":"","what":"Uploading Data","title":"Splitting Strata with Optimall Shiny","text":"first step using optimall_shiny() uploading data. data must format rest optimall’s functions require, meaning row must corresponds one sampling unit. already updated existing dataset R workflow, save updated dataframe .csv file order work optimall_shiny().","code":""},{"path":"https://yangjasp.github.io/optimall/articles/using-optimall_shiny.html","id":"splitting-strata","dir":"Articles","previous_headings":"","what":"Splitting Strata","title":"Splitting Strata with Optimall Shiny","text":"dataset uploaded, options user select inputs appear. input correspond argument least one function optimall, application provides list valid options one based uploaded data. See : Column Holding Strata corresponds strata argument split_strata(). dropdown menu includes list column names user choose name column defines stratum unit belongs . Column Holding Variable Split corresponds split_var argument split_strata(). dropdown menu includes list column names user choose name column holds variable (continuous categorical) used split strata . Column Holding Variable Interest corresponds y argument optimum_allocation() allocate_wave(). dropdown menu includes list column names user choose column holding variable interest. Since application displays, needs know variable interest, y, order calculate optimum allocation. Name Strata Split corresponds split argument split_strata(). dropdown menu includes list unique stratum names column holding strata. Although package allows multiple strata selected call, Shiny application currently supports one () strata split . Split Type corresponds split_type argument split_strata(). variable split numeric, type must categorical. details option, see documentation ?split_strata. Split corresponds split_at argument split_strata(). split type one global quantile, local quantile, value, input slider user adjust exact split location. split type categorical, input contain boxes unique value split_var. categorical case, checked boxes interpreted category 1, unchecked boxes category 0. Include Information Previous Wave allows users select displayed dataframe output optimum_allocation() allocate_wave(). optimum_allocation() chosen, defaults “WrightII” method allow.na = TRUE. allocate_wave() chosen, new option select column contains prior wave indicator appear, valid column (containing 0/1 Y/N) must selected. choice corresponds wave2a argument allocate_wave(). n sample allows users indicate number samples taken output dataframe. selection corresponds nsample argument either optimum_allocation() allocate_wave(). Thus, different depending allocation function selected. optimum_allocation(), total number samples taken, allocate_wave(), indicates many samples taken current wave.","code":""},{"path":"https://yangjasp.github.io/optimall/articles/using-optimall_shiny.html","id":"output","dir":"Articles","previous_headings":"","what":"Output","title":"Splitting Strata with Optimall Shiny","text":"optimall_shiny() displays output dataframe optimum_allocation() allocate_wave() based current inputs. split confirmed inputs reset, show error place dataframe valid inputs selected . Displayed dataframe text list code performs confirmed splits optimall.","code":""},{"path":"https://yangjasp.github.io/optimall/articles/using-optimall_shiny.html","id":"confirming-splits","dir":"Articles","previous_headings":"","what":"Confirming Splits","title":"Splitting Strata with Optimall Shiny","text":"user satisfied parameters selected, split can confirmed pressing Confirm Split button bottom left page. split existing data using split_strata() parameters specified inputs. inputs specify arguments allocation change splits, included show split may impact sample allocation. Confirm Split pressed, code perform split appear output bottom right page. updated strata now column called “new_strata”, inputs reset. Using “new_strata” column defining strata, user can perform splits, code perform one added list bottom right confirmation.","code":""},{"path":"https://yangjasp.github.io/optimall/articles/using-optimall_shiny.html","id":"implementing-splits-in-r","dir":"Articles","previous_headings":"","what":"Implementing Splits in R","title":"Splitting Strata with Optimall Shiny","text":"splits optimall_shiny() performed true dataset user’s optimall workflow R. Instead, user must return R want actually transform data working dataframe new strata. code displayed app’s output makes task simple, can copied pasted R script replicate splits conducted app. Note, however, data argument split_strata() call needs changed reflect user’s name data.","code":""},{"path":"https://yangjasp.github.io/optimall/articles/using-optimall_shiny.html","id":"error-messages","dir":"Articles","previous_headings":"","what":"Error Messages","title":"Splitting Strata with Optimall Shiny","text":"selected inputs results error either split_strata() selected allocation function, app print error.","code":""},{"path":"https://yangjasp.github.io/optimall/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Jasper Yang. Author, maintainer. Pamela Shaw. Author. Bryan Shepherd. Contributor. Thomas Lumley. Contributor. Gustavo Amorim. Reviewer.","code":""},{"path":"https://yangjasp.github.io/optimall/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Yang J, Shaw P (2024). optimall: Allocate Samples Among Strata. R package version 1.1.1, https://yangjasp.github.io/optimall/, https://github.com/yangjasp/optimall.","code":"@Manual{,   title = {optimall: Allocate Samples Among Strata},   author = {Jasper Yang and Pamela Shaw},   year = {2024},   note = {R package version 1.1.1, https://yangjasp.github.io/optimall/},   url = {https://github.com/yangjasp/optimall}, }"},{"path":"https://yangjasp.github.io/optimall/index.html","id":"optimall","dir":"","previous_headings":"","what":"Allocate Samples Among Strata","title":"Allocate Samples Among Strata","text":"optimall offers collection functions designed streamline process optimum sample allocation, specifically adaptive, multi-wave approach. main functions allow users : Define, split, merge strata based values quantiles variables. Calculate optimum number samples allocate stratum given study order minimize variance estimate interest. Select specific ids sample based stratified sampling design. Optimally allocate fixed number samples ancillary sampling wave based results prior wave. used together, functions can automate sampling workflow.","code":""},{"path":"https://yangjasp.github.io/optimall/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Allocate Samples Among Strata","text":"can install optimall CRAN : , can install development version GitHub :","code":"# install.packages(\"optimall\") # install.packages(\"devtools\") devtools::install_github(\"yangjasp/optimall\")"},{"path":"https://yangjasp.github.io/optimall/index.html","id":"example","dir":"","previous_headings":"","what":"Example","title":"Allocate Samples Among Strata","text":"Given dataframe row represents one unit, optimall can define stratum unit belongs : strata values split obvious, may useful try different splits observe effects sample allocation. optimall makes process quick easy Shiny app can launched optimall_shiny. app allows users adjust inputs split_strata function view results real time. parameters satisfactory, user can confirm split move ones desired. app prints code required replicate splits optimall, making changes inside R becomes easy copy paste! Screenshot: can use optimum_allocation calculate optimum allocation fixed number samples strata order minimize variance variable interest. optimall offers functions streamline adaptive, multi-wave sampling workflows. detailed description, see package vignettes.","code":"library(optimall) data <- split_strata(data = data, strata = \"old_strata\",                       split_var = \"variable_to_split_on\",                       type = \"value\", split_at = c(1,2)) optimum_allocation(data = data, strata = \"new_strata\",                     y = \"var_of_interest\", nsample = 100)"},{"path":"https://yangjasp.github.io/optimall/index.html","id":"references","dir":"","previous_headings":"","what":"References","title":"Allocate Samples Among Strata","text":"McIsaac MA, Cook RJ. Adaptive sampling two‐phase designs: biomarker study progression arthritis. Statistics Medicine. 2015 Sep 20;34(21):2899-912. Wright, T. (2014). simple method exact optimal sample allocation stratification mixed constraint patterns. Statistics, 07.","code":""},{"path":"https://yangjasp.github.io/optimall/reference/MatWgt_Sim.html","id":null,"dir":"Reference","previous_headings":"","what":"Example Dataset: Maternal Weights — MatWgt_Sim","title":"Example Dataset: Maternal Weights — MatWgt_Sim","text":"SIMULATED dataset contains data demographic characteristics clinical data related childhood obesity 10335 mother-child pairs. used generate workflow main package vignette. based study used multi-wave adaptive sampling validate electronic health records target factors related childhood obesity (see https://www.pcori.org/research-results/2017/developin-methods-estimate--address-errors-studies-using-electronic-health).","code":""},{"path":"https://yangjasp.github.io/optimall/reference/MatWgt_Sim.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Example Dataset: Maternal Weights — MatWgt_Sim","text":"MatWgt_Sim: data frame 10335 rows 6 columns id unique ID mother-child pair mat_weight_true true (unknown phase 1) mother weight change pregnancy mat_weight_est estimated mother weight change pregnancy based error-prone phase-1 measurement race specifies mother's race diabetes binary indicator diabetes mother obesity binary indicator childhood obesity child","code":""},{"path":"https://yangjasp.github.io/optimall/reference/MatWgt_Sim.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Example Dataset: Maternal Weights — MatWgt_Sim","text":"See package vignettes details.","code":""},{"path":"https://yangjasp.github.io/optimall/reference/Multiwave-class.html","id":null,"dir":"Reference","previous_headings":"","what":"Multiwave Class for Multi-Wave Sampling Organization — Multiwave-class","title":"Multiwave Class for Multi-Wave Sampling Organization — Multiwave-class","text":"optimall defines three S4 classes organizing multi-wave sampling workflow: Wave, Phase, Multiwave. object class Multiwave holds metadata list objects class Phase, turn holds metadata list objects class Wave. three object classes used together organize workflow multi-wave sampling designs.","code":""},{"path":"https://yangjasp.github.io/optimall/reference/Multiwave-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"Multiwave Class for Multi-Wave Sampling Organization — Multiwave-class","text":"metadata list elements describe entire survey. list empty upon initialization multiwave object, user may add anything see fit. may include \"title\". phases list objects class Phase (see class documentation).","code":""},{"path":"https://yangjasp.github.io/optimall/reference/Phase-class.html","id":null,"dir":"Reference","previous_headings":"","what":"Phase Class for Multi-Wave Sampling Organization — Phase-class","title":"Phase Class for Multi-Wave Sampling Organization — Phase-class","text":"optimall defines three S4 classes organizing multi-wave sampling workflow: Wave, Phase, Multiwave. object class Multiwave holds metadata list objects class Phase, turn holds metadata list objects class Wave. three object classes used together organize workflow multi-wave sampling designs.","code":""},{"path":"https://yangjasp.github.io/optimall/reference/Phase-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"Phase Class for Multi-Wave Sampling Organization — Phase-class","text":"metadata list containing phase metadata waves list objects class Wave, element representing one wave phase","code":""},{"path":"https://yangjasp.github.io/optimall/reference/Wave-class.html","id":null,"dir":"Reference","previous_headings":"","what":"Wave Class for Multi-Wave Sampling Organization — Wave-class","title":"Wave Class for Multi-Wave Sampling Organization — Wave-class","text":"optimall defines three S4 classes organizing multi-wave sampling workflow: Wave, Phase, Multiwave. object class Multiwave holds metadata list objects class Phase, turn holds metadata list objects class Wave. three object classes used together organize workflow multi-wave sampling designs.","code":""},{"path":"https://yangjasp.github.io/optimall/reference/Wave-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"Wave Class for Multi-Wave Sampling Organization — Wave-class","text":"metadata list containing metadata wave. design dataframe specifying design wave. often output allocate_wave. samples character vector containing ids units sampled wave. sampled_data dataframe holding data, ids, collected wave sampling data dataframe holding updated full data set Phase 1 sampling units including samples collected wave.","code":""},{"path":"https://yangjasp.github.io/optimall/reference/allocate_wave.html","id":null,"dir":"Reference","previous_headings":"","what":"Adaptive Multi-Wave Sampling — allocate_wave","title":"Adaptive Multi-Wave Sampling — allocate_wave","text":"Determines adaptive optimum sampling allocation new sampling wave based results previous waves. Using Neyman Wright (2014) allocation, allocate_wave calculates optimum allocation total number samples across waves, determines many allocated strata previous waves, allocates remaining samples make difference.","code":""},{"path":"https://yangjasp.github.io/optimall/reference/allocate_wave.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Adaptive Multi-Wave Sampling — allocate_wave","text":"","code":"allocate_wave(   data,   strata,   y,   already_sampled,   nsample,   allocation_method = c(\"WrightII\", \"WrightI\", \"Neyman\"),   method = c(\"iterative\", \"simple\"),   detailed = FALSE )"},{"path":"https://yangjasp.github.io/optimall/reference/allocate_wave.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Adaptive Multi-Wave Sampling — allocate_wave","text":"data data frame matrix one row sampling unit, one column specifying unit's stratum, one column holding value continuous variable variance minimized, one column containing binary indicator, already_sampled, specifying whether unit already sampled. strata character string vector character strings specifying name columns indicate stratum unit belongs . y character string specifying name continuous variable variance minimized. already_sampled character string specifying name column contains binary (Y/N 1 /0) indicator specifying whether unit already sampled previous wave. nsample desired sample size next wave. allocation_method character string specifying method optimum sample allocation use. details see optimum_allocation(). Defaults WrightII exact Neyman may run slower. method character string specifying method used least one group oversampled. Must one : \"iterative\", default, require longer runtime may precise method handling oversampled strata. multiple oversampled strata, method closes strata re-calculates optimum allocation one one. \"simple\" closes oversampled together re-calculates optimum allocation rest strata . certain cases many strata oversampled prior waves, possible method output negative value n_to_sample. occurs, function print warning, recommended user re-runs allocation 'iterative' method. detailed logical value indicating whether output dataframe include details stratum including true optimum allocation without constraint previous waves sampling stratum standard deviations. Defaults FALSE, unless called within apply_multiwave(). details available optimum_allocation().","code":""},{"path":"https://yangjasp.github.io/optimall/reference/allocate_wave.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Adaptive Multi-Wave Sampling — allocate_wave","text":"Returns dataframe one row stratum columns specifying stratum name (\"strata\"), population stratum size (\"npop\"), cumulative sample strata (\"nsample_actual\"), prior number sampled strata (\"nsample_prior\"), optimally allocated number units strata next wave (\"n_to_sample\").","code":""},{"path":"https://yangjasp.github.io/optimall/reference/allocate_wave.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Adaptive Multi-Wave Sampling — allocate_wave","text":"optimum sample size stratum smaller amount allocated previous waves, strata oversampled. oversampling occurs, allocate_wave \"closes\" oversampled strata re-allocates remaining samples optimally among open strata. circumstances, total sampling allocation longer optimal, optimall output optimal allocation possible next wave.","code":""},{"path":"https://yangjasp.github.io/optimall/reference/allocate_wave.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Adaptive Multi-Wave Sampling — allocate_wave","text":"McIsaac MA, Cook RJ. Adaptive sampling two-phase designs: biomarker study progression arthritis. Statistics medicine. 2015 Sep 20;34(21):2899-912. Reilly, M., & Pepe, M. S. (1995). mean score method missing auxiliary covariate data regression models. Biometrika, 82(2), 299-314. Wright, T. (2014). Simple Method Exact Optimal Sample Allocation Stratification Mixed Constraint Patterns, Research Report Series (Statistics #2014-07), Center Statistical Research Methodology, U.S. Bureau Census, Washington, D.C.","code":""},{"path":"https://yangjasp.github.io/optimall/reference/allocate_wave.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Adaptive Multi-Wave Sampling — allocate_wave","text":"","code":"# Create dataframe with a column specifying strata, a variable of interest # and an indicator for whether each unit was already sampled set.seed(234) mydata <- data.frame(Strata = c(rep(1, times = 20),                                 rep(2, times = 20),                                 rep(3, times = 20)),                      Var = c(rnorm(20, 1, 0.5),                              rnorm(20, 1, 0.9),                              rnorm(20, 1.5, 0.9)),                      AlreadySampled = rep(c(rep(1, times = 5),                                             rep(0, times = 15)),                                           times = 3))  x <- allocate_wave(   data = mydata, strata = \"Strata\",   y = \"Var\", already_sampled = \"AlreadySampled\",   nsample = 20, method = \"simple\" )"},{"path":"https://yangjasp.github.io/optimall/reference/apply_multiwave.html","id":null,"dir":"Reference","previous_headings":"","what":"Apply a basic optimall function to a Multiwave Object — apply_multiwave","title":"Apply a basic optimall function to a Multiwave Object — apply_multiwave","text":"Given specified phase wave object class multiwave, apply_multiwave applies one four optimall functions returns updated multiwave object output applied function specified slot.","code":""},{"path":"https://yangjasp.github.io/optimall/reference/apply_multiwave.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Apply a basic optimall function to a Multiwave Object — apply_multiwave","text":"","code":"apply_multiwave(x, phase, wave, fun, ...)  # S4 method for Multiwave apply_multiwave(x, phase, wave, fun, ...)"},{"path":"https://yangjasp.github.io/optimall/reference/apply_multiwave.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Apply a basic optimall function to a Multiwave Object — apply_multiwave","text":"x Object class \"multiwave\" phase numeric character value specifying phase multiwave desired output placed. wave numeric character value specifying wave phase multiwave output placed. fun character value specifying name optimall function apply. four available functions : optimum_allocation, allocate_wave, sample_strata, merge_samples. optimum_allocation: Uses data previous wave (previous phase wave = 1) determine optimum sampling allocation specified wave. used, output multiwave object contains updated \"design\" slot specified wave. allocate_wave: Uses data previous wave (previous phase wave = 1) determine optimum sampling allocation specified wave. used, outputted multiwave object contains updated \"design\" slot specified wave. default argument allocate_wave applied apply_multiwave() detailed = TRUE. sample_strata: Uses data previous wave (previous phase wave = 1) design current wave generate vector ids sample current wave. Note wave argument standalone sample_strata() function apply , used, output multiwave object contains updated \"samples\" slot specified wave. merge_samples: Uses data previous wave (previous phase wave = 1) sampled_data specified wave generate final, merged data current wave. used, output multiwave object contains updated \"data\" slot specified wave. Note merge_samples already method multiwave objects, calling apply_multiwave exact calling . See documentation functions details specific uses arguments. ... Optional arguments given fun. necessary arguments already provided named values wave, phase, overall metadata multiwave object. Arguments provided override specifications metadata provided places.","code":""},{"path":"https://yangjasp.github.io/optimall/reference/apply_multiwave.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Apply a basic optimall function to a Multiwave Object — apply_multiwave","text":"inputted multiwave object one slot updated include output specified function. Note phase wave arguments specify function output placed. apply_multiwave determine get input dataframes (returning error slots empty invalid) given specified wave output. example, phase = 2, wave = 2, function = \"allocate_wave\", data determine optimum allocation taken previous wave (phase 2, wave 1) output multiwave object updated \"design\" slot phase 2, wave 2.","code":""},{"path":"https://yangjasp.github.io/optimall/reference/apply_multiwave.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Apply a basic optimall function to a Multiwave Object — apply_multiwave","text":"","code":"library(datasets)  MySurvey <- multiwave(phases = 2, waves = c(1, 3)) set_mw(MySurvey, phase = 1, slot = \"data\") <-   dplyr::select(datasets::iris, -Sepal.Width)  # Get Design by applying optimum_allocation MySurvey <- apply_multiwave(MySurvey,   phase = 2, wave = 1,   fun = \"optimum_allocation\", strata = \"Species\",   y = \"Sepal.Length\",   nsample = 15,   method = \"WrightII\" )  # or, we can establish function args in the metadata set_mw(MySurvey, phase = 2, slot = \"metadata\") <- list(   strata = \"Species\",   nsample = 15,   y = \"Sepal.Length\",   method = \"WrightII\" )  # which allows the function to be run without specifying the args MySurvey <- apply_multiwave(MySurvey,   phase = 2, wave = 1,   fun = \"optimum_allocation\" )"},{"path":"https://yangjasp.github.io/optimall/reference/get_mw.html","id":null,"dir":"Reference","previous_headings":"","what":"Access Slots of a Multiwave Object — get_mw","title":"Access Slots of a Multiwave Object — get_mw","text":"get_mw accessor function objects class Multiwave. used get values multiwave (mw) objects.","code":""},{"path":"https://yangjasp.github.io/optimall/reference/get_mw.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Access Slots of a Multiwave Object — get_mw","text":"","code":"get_mw(   x,   phase = 1,   wave = NA,   slot = c(\"data\", \"design\", \"metadata\", \"samples\", \"sampled_data\") )  get_data(   x,   phase = 1,   wave = NA,   slot = c(\"data\", \"design\", \"metadata\", \"samples\", \"sampled_data\") )  get_data(   x,   phase = 1,   wave = NA,   slot = c(\"data\", \"design\", \"metadata\", \"samples\", \"sampled_data\") ) <- value"},{"path":"https://yangjasp.github.io/optimall/reference/get_mw.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Access Slots of a Multiwave Object — get_mw","text":"x object class 'Multiwave' phase numeric value specifying phase accessed. access overall metadata, set phase = NA. Defaults 1. wave numeric value specifying wave accessed. Ta access phase metadata, set wave = NA. Defaults NA. slot character value specifying name slot accessed. Must one \"metadata\", \"design\", \"samples\", \"sampled_data\", \"data\". Defaults \"data\". See class documentation package vignettes information slots. value value assign specified slot","code":""},{"path":"https://yangjasp.github.io/optimall/reference/get_mw.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Access Slots of a Multiwave Object — get_mw","text":"accessing multiwave object slot, returns specified slot.","code":""},{"path":"https://yangjasp.github.io/optimall/reference/get_mw.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"Access Slots of a Multiwave Object — get_mw","text":"get_mw(): access slot multiwave object get_data(): access slot multiwave object get_data(   x,   phase = 1,   wave = NA,   slot = c(\"data\", \"design\", \"metadata\", \"samples\", \"sampled_data\") ) <- value: assign value slot multiwave object","code":""},{"path":"https://yangjasp.github.io/optimall/reference/get_mw.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Access Slots of a Multiwave Object — get_mw","text":"","code":"# Intiate multiwave object MySurvey <- multiwave(phases = 2, waves = c(1, 3))  # To access overall metadata get_mw(MySurvey, phase = NA, slot = \"metadata\") #> list()  # To write overall metadata set_mw(MySurvey, phase = NA, slot = \"metadata\") <- list(   title = \"Maternal Weight Survey\" )  # To access Phase 2 metadata get_mw(MySurvey, phase = 2, slot = \"metadata\") #> list()  # To access Phase 2, Wave 2 design get_mw(MySurvey, phase = 2, wave = 2, slot = \"design\") #> data frame with 0 columns and 0 rows"},{"path":"https://yangjasp.github.io/optimall/reference/merge_samples.html","id":null,"dir":"Reference","previous_headings":"","what":"Merge Sampled Data based on IDs — merge_samples","title":"Merge Sampled Data based on IDs — merge_samples","text":"object class \"Mutiwave\", merge_samples creates dataframe \"data\" slot specified wave merging dataframe \"sampled data\" slot dataframe \"data\" slot previous wave.","code":""},{"path":"https://yangjasp.github.io/optimall/reference/merge_samples.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Merge Sampled Data based on IDs — merge_samples","text":"","code":"merge_samples(   x,   phase,   wave,   id = NULL,   phase_sample_ind = \"sampled_phase\",   wave_sample_ind = \"sampled_wave\",   include_probs = NULL )"},{"path":"https://yangjasp.github.io/optimall/reference/merge_samples.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Merge Sampled Data based on IDs — merge_samples","text":"x object class \"Multiwave\". phase numeric value specifying phase Multiwave object specified wave . phase 1. wave numeric value specifying wave Multiwave object merge performed . wave must valid dataframe \"sampled data\" slot. previous wave, taken final wave previous phase wave = 1, must valid dataframe \"data\" slot. id character value specifying name column holding unit ids. Taken wave, phase, overall metadata (searched order) NULL. Defaults NULL. phase_sample_ind character value specifying name column hold indicator whether unit already sampled current phase. specified phase number appended end given character name. Defaults \"sampled_phase\". wave_sample_ind character value specifying name column hold indicator whether unit already sampled current wave. specified phase wave numbers separated \".\" appended o end given character name. FALSE, column created. Defaults \"sampled_wave\". include_probs logical value. TRUE, looks \"probs\" design_data slot includes corresponding sampling probability element sampled current wave merged data column named \"sampling_prob\". column already exists, keeps existing column adds (replaces) values units sampled current wave. Returns error specified wave_sample_wave FALSE. Defaults NULL, looks \"probs\" argument metadata create (add existing) \"sampling_prob\" column none found.","code":""},{"path":"https://yangjasp.github.io/optimall/reference/merge_samples.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Merge Sampled Data based on IDs — merge_samples","text":"Multiwave object merged dataframe \"data\" slot specified wave.","code":""},{"path":"https://yangjasp.github.io/optimall/reference/merge_samples.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Merge Sampled Data based on IDs — merge_samples","text":"Columns \"sampled_data\" match names \"data\" previous wave added new columns output dataframe. ids appear \"sampled_data\" receive NA values new variables. column name \"sampled_data\" matches column name \"data\" slot previous wave, columns merged one column name output dataframe. ids non-missing values columns merge, value \"sampled_data\" overwrite previous value warning printed. ids present \"data\" previous wave missing \"sampled_data\" given NA values newly merged variables. columns name produced phase_sample_ind wave_sample_ind already exist, overwritten.","code":""},{"path":"https://yangjasp.github.io/optimall/reference/merge_samples.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Merge Sampled Data based on IDs — merge_samples","text":"","code":"library(datasets) iris <- data.frame(iris, id = 1:150)  MySurvey <- multiwave(phases = 2, waves = c(1, 3)) set_mw(MySurvey, phase = 1, slot = \"data\") <-   data.frame(dplyr::select(iris, -Sepal.Width)) set_mw(MySurvey, phase = 2, wave = 1, slot = \"sampled_data\") <-   dplyr::select(iris, id, Sepal.Width)[1:40, ] set_mw(MySurvey, phase = 2, wave = 1, slot = \"samples\") <-    list(ids = 1:40) MySurvey <- merge_samples(MySurvey, phase = 2, wave = 1, id = \"id\")"},{"path":"https://yangjasp.github.io/optimall/reference/merge_strata.html","id":null,"dir":"Reference","previous_headings":"","what":"Merge Strata — merge_strata","title":"Merge Strata — merge_strata","text":"Merges multiple pre-defined sampling strata single stratum.","code":""},{"path":"https://yangjasp.github.io/optimall/reference/merge_strata.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Merge Strata — merge_strata","text":"","code":"merge_strata(data, strata, merge, name = NULL)"},{"path":"https://yangjasp.github.io/optimall/reference/merge_strata.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Merge Strata — merge_strata","text":"data dataframe matrix one row sampling unit, one column, strata, specifying unit's current stratum, relevant columns. strata character string specifying name column defines unit's current strata. merge names strata merged, exactly appear strata. name character name new stratum. Defaults NULL, pastes old strata names together create new stratum name.","code":""},{"path":"https://yangjasp.github.io/optimall/reference/merge_strata.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Merge Strata — merge_strata","text":"Returns input dataframe new column named 'new_strata' holds name stratum sample belongs merge. column containing previous strata names retained given name 'old_strata'.","code":""},{"path":"https://yangjasp.github.io/optimall/reference/merge_strata.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Merge Strata — merge_strata","text":"","code":"x <- merge_strata(iris,   strata = \"Species\",   merge = c(\"virginica\", \"versicolor\"), name = \"v_species\" )"},{"path":"https://yangjasp.github.io/optimall/reference/multiwave.html","id":null,"dir":"Reference","previous_headings":"","what":"Initialize a Multiwave Object — multiwave","title":"Initialize a Multiwave Object — multiwave","text":"multiwave() Creates Object Class Multiwave specified number phases waves. contents NULL upon initialization, object contains framework contents added survey design sample collection process. Currently, multiwave objects may one wave Phase 1.","code":""},{"path":"https://yangjasp.github.io/optimall/reference/multiwave.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Initialize a Multiwave Object — multiwave","text":"","code":"multiwave(phases, waves, metadata = list(), phase1 = data.frame())  new_multiwave(phases, waves, metadata = list(), phase1 = data.frame())"},{"path":"https://yangjasp.github.io/optimall/reference/multiwave.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Initialize a Multiwave Object — multiwave","text":"phases numeric value specifying number phases survey design. waves vector numeric values specifying number waves phase survey design. Length must match number phases first metadata list containing survey metadata. Defaults empty list. phase1 dataframe containing phase 1 data survey. Defaults empty dataframe.","code":""},{"path":"https://yangjasp.github.io/optimall/reference/multiwave.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Initialize a Multiwave Object — multiwave","text":"Returns object class Multiwave stores relevant data survey design organized easy--access manner. See package vignettes class documentation information.","code":""},{"path":"https://yangjasp.github.io/optimall/reference/multiwave.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Initialize a Multiwave Object — multiwave","text":"","code":"# Initialize a multiwave object for a two-phase sampling design that will # sample over three waves in the second phase multiwave_object <- multiwave(phases = 2, waves = c(1, 3))  # If we already have the phase 1 data and want to add a title to the survey # metadata, we can initialize the object with these included.  library(datasets) multiwave_object <- multiwave(   phases = 2, waves = c(1, 3),   metadata = list(title = \"my two-phase survey\"), phase1 = iris )"},{"path":"https://yangjasp.github.io/optimall/reference/multiwave_diagram.html","id":null,"dir":"Reference","previous_headings":"","what":"Print Summary Diagram of Multiwave Object — multiwave_diagram","title":"Print Summary Diagram of Multiwave Object — multiwave_diagram","text":"Takes multiwave object input plots diagram structure plotting window using grViz() DiagrammeR package. Red boxes indicate slots yet filled, blue boxes indicate slot filled.","code":""},{"path":"https://yangjasp.github.io/optimall/reference/multiwave_diagram.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print Summary Diagram of Multiwave Object — multiwave_diagram","text":"","code":"multiwave_diagram(x, height = NULL, width = NULL)"},{"path":"https://yangjasp.github.io/optimall/reference/multiwave_diagram.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print Summary Diagram of Multiwave Object — multiwave_diagram","text":"x object class multiwave. height height pixels diagram. Defaults NULL , produces default height. width width pixels diagram. Defaults NULL, produces default width.","code":""},{"path":"https://yangjasp.github.io/optimall/reference/multiwave_diagram.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Print Summary Diagram of Multiwave Object — multiwave_diagram","text":"Returns object class htmlwidget displaying structure x.","code":""},{"path":"https://yangjasp.github.io/optimall/reference/multiwave_diagram.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Print Summary Diagram of Multiwave Object — multiwave_diagram","text":"","code":"MySurvey <- multiwave(phases = 2, waves = c(1, 3)) multiwave_diagram(MySurvey)  {\"x\":{\"diagram\":\"digraph {\\ngraph [layout = dot, rankdir = LR]\\nnode [shape = rectangle, fixedsize= true, width = 4.5,\\nheight = 1.5, fontname = Helvetica, fontsize = 20]\\nrec1 [label = <<b>Multiwave Object<\\/b>>,\\n  fillcolor = lightgray, style = filled]\\nrec2 [label = <<b>Metadata<\\/b> > , fillcolor = lightcoral, style = filled] rec3 [label = <<b>Phase 1<\\/b>>, fillcolor = burlywood, style = filled] rec4 [label = <<b>Metadata<\\/b> > , fillcolor = lightcoral, style = filled] rec5 [label = <<b>Data<\\/b> > , fillcolor = lightcoral, style = filled]\\nrec6 [label = <<b>Phase 2<\\/b>>, fillcolor = burlywood, style = filled] rec7 [label = <<b>Metadata<\\/b> >, fillcolor = lightcoral, style = filled] rec8 [label = <<b>Wave 1<\\/b>>, fillcolor = burlywood, style = filled] rec9 [label = <<b>Metadata<\\/b> > , fillcolor = lightcoral, style = filled] rec10 [label = <<b>Design<\\/b> > , fillcolor = lightcoral, style = filled] rec11 [label = <<b>Sample IDs<\\/b> > , fillcolor = lightcoral, style = filled] rec12 [label = <<b>Sampled Data<\\/b> > , fillcolor = lightcoral, style = filled] rec13 [label = <<b>Data<\\/b> > , fillcolor = lightcoral, style = filled] rec14 [label = <<b>Wave 2<\\/b>>, fillcolor = burlywood, style = filled] rec15 [label = <<b>Metadata<\\/b> > , fillcolor = lightcoral, style = filled] rec16 [label = <<b>Design<\\/b> > , fillcolor = lightcoral, style = filled] rec17 [label = <<b>Sample IDs<\\/b> > , fillcolor = lightcoral, style = filled] rec18 [label = <<b>Sampled Data<\\/b> > , fillcolor = lightcoral, style = filled] rec19 [label = <<b>Data<\\/b> > , fillcolor = lightcoral, style = filled] rec20 [label = <<b>Wave 3<\\/b>>, fillcolor = burlywood, style = filled] rec21 [label = <<b>Metadata<\\/b> > , fillcolor = lightcoral, style = filled] rec22 [label = <<b>Design<\\/b> > , fillcolor = lightcoral, style = filled] rec23 [label = <<b>Sample IDs<\\/b> > , fillcolor = lightcoral, style = filled] rec24 [label = <<b>Sampled Data<\\/b> > , fillcolor = lightcoral, style = filled] rec25 [label = <<b>Data<\\/b> > , fillcolor = lightcoral, style = filled]\\n# edge definitions with node ids\\nrec1 -> rec2\\nrec1 -> rec3 -> {rec4 rec5}\\nrec1 -> rec6 rec6 -> { rec7 rec8 rec7 rec14 rec7 rec20 } rec8 -> { rec9 rec10 rec11 rec12 rec13 } rec14 -> { rec15 rec16 rec17 rec18 rec19 } rec20 -> { rec21 rec22 rec23 rec24 rec25 }\\n}\",\"config\":{\"engine\":\"dot\",\"options\":null}},\"evals\":[],\"jsHooks\":[]}"},{"path":"https://yangjasp.github.io/optimall/reference/optimall_shiny.html","id":null,"dir":"Reference","previous_headings":"","what":"Run the shiny application — optimall_shiny","title":"Run the shiny application — optimall_shiny","text":"Launches R Shiny application locally. app can used interactively split strata determine results affect optimum allocation fixed number samples. accepts .csv .rds files well .rda files contain single dataset. See vignette titled \"Splitting Strata Optimall Shiny\" information.","code":""},{"path":"https://yangjasp.github.io/optimall/reference/optimall_shiny.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Run the shiny application — optimall_shiny","text":"","code":"optimall_shiny(...)"},{"path":"https://yangjasp.github.io/optimall/reference/optimall_shiny.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Run the shiny application — optimall_shiny","text":"... Optional arguments pass shiny::runApp. display.mode already set normal.","code":""},{"path":"https://yangjasp.github.io/optimall/reference/optimall_shiny.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Run the shiny application — optimall_shiny","text":"Launches R Shiny application locally.","code":""},{"path":"https://yangjasp.github.io/optimall/reference/optimum_allocation.html","id":null,"dir":"Reference","previous_headings":"","what":"Optimum Allocation — optimum_allocation","title":"Optimum Allocation — optimum_allocation","text":"Determines optimum sampling fraction sample size stratum stratified random sample, minimizes variance sample mean according Neyman Allocation Exact Optimum Sample Allocation (Wright 2014).","code":""},{"path":"https://yangjasp.github.io/optimall/reference/optimum_allocation.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Optimum Allocation — optimum_allocation","text":"","code":"optimum_allocation(   data,   strata,   y = NULL,   sd_h = NULL,   N_h = NULL,   nsample = NULL,   ndigits = 2,   method = c(\"WrightII\", \"WrightI\", \"Neyman\"),   allow.na = FALSE )"},{"path":"https://yangjasp.github.io/optimall/reference/optimum_allocation.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Optimum Allocation — optimum_allocation","text":"data data frame matrix least one column specifying unit's stratum, either 1) second column holding value continuous variable sample mean variance minimized (y) 2) two columns: one holding within-stratum standard deviation variable interest (sd_h) another holding stratum sample sizes (N_h). data contains column y holding values variable interest, data one row sampled unit. data holds sd_h N_h, within-stratum standard deviations population sizes, data one row per stratum. columns allowed ignored. strata character string vector character strings specifying name(s) columns specify stratum unit belongs . multiple column names provided, unique combination values columns taken define one stratum. y character string specifying name continuous variable variance minimized. Defaults NULL left NULL data holds stratum standard deviations sample sizes instead individual sampling units. sd_h character string specifying name column holding within-stratum standard deviations stratum. Defaults NULL left NULL data holds individual sampling units. N_h character string specifying name column holding population stratum sizes stratum. Defaults NULL left NULL data holds individual sampling units. nsample desired total sample size. Defaults NULL. ndigits numeric value specifying number digits standard deviation stratum fraction rounded. Defaults 2. method character string specifying method optimum sample allocation use. Must one : \"WrightII\", default, uses Algorithm II Wright (2014) determine optimum allocation fixed sample size across strata. requires least two samples allocated stratum. \"WrightI\" uses Wright's Algorithm determine optimum sample allocation. requires least one sample allocated stratum, can therefore lead biased variance estimate. \"Neyman\" uses standard method Neyman Allocation determine optimum sample allocation. nsample = NULL, optimal sampling fraction calculated returned. numeric value specified nsample, number allocated stratum optimal sampling fraction times nsample rounded nearest integer, may longer optimall. allow.na logical input specifying whether y allowed NA values. Defaults FALSE.","code":""},{"path":"https://yangjasp.github.io/optimall/reference/optimum_allocation.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Optimum Allocation — optimum_allocation","text":"Returns data frame number samples allocated stratum, just sampling fractions nsample NULL.","code":""},{"path":"https://yangjasp.github.io/optimall/reference/optimum_allocation.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Optimum Allocation — optimum_allocation","text":"Wright, T. (2014). Simple Method Exact Optimal Sample Allocation Stratification Mixed Constraint Patterns, Research Report Series (Statistics #2014-07), Center Statistical Research Methodology, U.S. Bureau Census, Washington, D.C.","code":""},{"path":"https://yangjasp.github.io/optimall/reference/optimum_allocation.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Optimum Allocation — optimum_allocation","text":"","code":"optimum_allocation(   data = iris, strata = \"Species\", y = \"Sepal.Length\",   nsample = 40, method = \"WrightII\" ) #>       strata npop   sd  n_sd stratum_fraction stratum_size #> 1     setosa   50 0.35 17.62             0.22            9 #> 2 versicolor   50 0.52 25.81             0.35           14 #> 3  virginica   50 0.64 31.79             0.42           17  # Or if input data is summary of strata sd and N: iris_summary <- data.frame(   strata = unique(iris$Species),   size = c(50, 50, 50),   sd = c(0.3791, 0.3138, 0.3225) )  optimum_allocation(   data = iris_summary, strata = \"strata\",   sd_h = \"sd\", N_h = \"size\",   nsample = 40, method = \"WrightII\" ) #>       strata npop   sd  n_sd stratum_fraction stratum_size #> 1     setosa   50 0.38 18.95             0.38           15 #> 2 versicolor   50 0.31 15.69             0.30           12 #> 3  virginica   50 0.32 16.12             0.32           13"},{"path":"https://yangjasp.github.io/optimall/reference/sample_strata.html","id":null,"dir":"Reference","previous_headings":"","what":"Select Sampling Units based on Stratified Random Sampling — sample_strata","title":"Select Sampling Units based on Stratified Random Sampling — sample_strata","text":"Requires two dataframes matrices: data column strata specifies stratum membership unit population second dataframe design_data one row per strata level column design_strata indicates unique levels strata data n_allocated specifies number sampled stratum. sample_strata selects units sample selecting random sample desired size within stratum. second dataframe can output allocate_wave() optimum_allocation().","code":""},{"path":"https://yangjasp.github.io/optimall/reference/sample_strata.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Select Sampling Units based on Stratified Random Sampling — sample_strata","text":"","code":"sample_strata(   data,   strata,   id,   already_sampled = NULL,   design_data,   design_strata = \"strata\",   n_allocated = \"n_to_sample\",   probs = NULL,   wave = NULL,   warn_prob_overwrite = TRUE )"},{"path":"https://yangjasp.github.io/optimall/reference/sample_strata.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Select Sampling Units based on Stratified Random Sampling — sample_strata","text":"data data frame matrix one row sampling unit population, one column specifying unit's stratum, one column unique identifier unit. strata character string specifying name column data indicates stratum membership. id character string specifying name column data uniquely identifies unit. already_sampled character sting specifying name column data indicates (1/0 Y/N) whether unit already sampled prior wave. Defaults NULL means none sampled yet. design_data dataframe matrix one row stratum subdivides population, one column specifying stratum name, one column indicating number samples allocated stratum. design_strata character string specifying name column design_data contains stratum levels. Defaults \"strata\". n_allocated character string specifying name column design_data indicates n allocated stratum. Defaults \"n_to_sample\". probs character string specifying name column design_data indicates sampling probability stratum, formula indicating sampling probabilities can computed. existing columns. specified, new column containing sampling probability attached sampled unit created outputted dataframe. column named \"sampling_prob\". Defaults NULL. wave numeric value character string indicating sampling wave. specified, input appended \"sample_indicator\" new sample indicator column name (long columns name already exist data). Defaults NULL. argument apply sample_strata() called inside allocate_wave(). warn_prob_overwrite Logical indicator whether warning printed probs specified \"sampling_prob\" columns going overwritten. Defaults TRUE. function called inside apply_multiwave(), defaults FALSE","code":""},{"path":"https://yangjasp.github.io/optimall/reference/sample_strata.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Select Sampling Units based on Stratified Random Sampling — sample_strata","text":"returns data dataframe new column named \"sample_indicator\" containing binary (1/0) indicator whether unit sampled. wave argument specified, given input appended name \"sample_indicator\". probs argument specified, dataframe also contain new column named \"sampling_prob\" holding sampling probabilities sampled element.","code":""},{"path":"https://yangjasp.github.io/optimall/reference/sample_strata.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Select Sampling Units based on Stratified Random Sampling — sample_strata","text":"","code":"# Define a design dataframe design <- data.frame(   strata = c(\"setosa\", \"virginica\", \"versicolor\"),   npop = c(50, 50, 50),   n_to_sample = c(5, 5, 5) )  # Make sure there is an id column iris$id <- 1:nrow(iris)  # Run sample_strata(   data = iris, strata = \"Species\", id = \"id\",   design_data = design, design_strata = \"strata\",   n_allocated = \"n_to_sample\" ) #>     Sepal.Length Sepal.Width Petal.Length Petal.Width    Species  id #> 1            5.1         3.5          1.4         0.2     setosa   1 #> 2            4.9         3.0          1.4         0.2     setosa   2 #> 3            4.7         3.2          1.3         0.2     setosa   3 #> 4            4.6         3.1          1.5         0.2     setosa   4 #> 5            5.0         3.6          1.4         0.2     setosa   5 #> 6            5.4         3.9          1.7         0.4     setosa   6 #> 7            4.6         3.4          1.4         0.3     setosa   7 #> 8            5.0         3.4          1.5         0.2     setosa   8 #> 9            4.4         2.9          1.4         0.2     setosa   9 #> 10           4.9         3.1          1.5         0.1     setosa  10 #> 11           5.4         3.7          1.5         0.2     setosa  11 #> 12           4.8         3.4          1.6         0.2     setosa  12 #> 13           4.8         3.0          1.4         0.1     setosa  13 #> 14           4.3         3.0          1.1         0.1     setosa  14 #> 15           5.8         4.0          1.2         0.2     setosa  15 #> 16           5.7         4.4          1.5         0.4     setosa  16 #> 17           5.4         3.9          1.3         0.4     setosa  17 #> 18           5.1         3.5          1.4         0.3     setosa  18 #> 19           5.7         3.8          1.7         0.3     setosa  19 #> 20           5.1         3.8          1.5         0.3     setosa  20 #> 21           5.4         3.4          1.7         0.2     setosa  21 #> 22           5.1         3.7          1.5         0.4     setosa  22 #> 23           4.6         3.6          1.0         0.2     setosa  23 #> 24           5.1         3.3          1.7         0.5     setosa  24 #> 25           4.8         3.4          1.9         0.2     setosa  25 #> 26           5.0         3.0          1.6         0.2     setosa  26 #> 27           5.0         3.4          1.6         0.4     setosa  27 #> 28           5.2         3.5          1.5         0.2     setosa  28 #> 29           5.2         3.4          1.4         0.2     setosa  29 #> 30           4.7         3.2          1.6         0.2     setosa  30 #> 31           4.8         3.1          1.6         0.2     setosa  31 #> 32           5.4         3.4          1.5         0.4     setosa  32 #> 33           5.2         4.1          1.5         0.1     setosa  33 #> 34           5.5         4.2          1.4         0.2     setosa  34 #> 35           4.9         3.1          1.5         0.2     setosa  35 #> 36           5.0         3.2          1.2         0.2     setosa  36 #> 37           5.5         3.5          1.3         0.2     setosa  37 #> 38           4.9         3.6          1.4         0.1     setosa  38 #> 39           4.4         3.0          1.3         0.2     setosa  39 #> 40           5.1         3.4          1.5         0.2     setosa  40 #> 41           5.0         3.5          1.3         0.3     setosa  41 #> 42           4.5         2.3          1.3         0.3     setosa  42 #> 43           4.4         3.2          1.3         0.2     setosa  43 #> 44           5.0         3.5          1.6         0.6     setosa  44 #> 45           5.1         3.8          1.9         0.4     setosa  45 #> 46           4.8         3.0          1.4         0.3     setosa  46 #> 47           5.1         3.8          1.6         0.2     setosa  47 #> 48           4.6         3.2          1.4         0.2     setosa  48 #> 49           5.3         3.7          1.5         0.2     setosa  49 #> 50           5.0         3.3          1.4         0.2     setosa  50 #> 51           7.0         3.2          4.7         1.4 versicolor  51 #> 52           6.4         3.2          4.5         1.5 versicolor  52 #> 53           6.9         3.1          4.9         1.5 versicolor  53 #> 54           5.5         2.3          4.0         1.3 versicolor  54 #> 55           6.5         2.8          4.6         1.5 versicolor  55 #> 56           5.7         2.8          4.5         1.3 versicolor  56 #> 57           6.3         3.3          4.7         1.6 versicolor  57 #> 58           4.9         2.4          3.3         1.0 versicolor  58 #> 59           6.6         2.9          4.6         1.3 versicolor  59 #> 60           5.2         2.7          3.9         1.4 versicolor  60 #> 61           5.0         2.0          3.5         1.0 versicolor  61 #> 62           5.9         3.0          4.2         1.5 versicolor  62 #> 63           6.0         2.2          4.0         1.0 versicolor  63 #> 64           6.1         2.9          4.7         1.4 versicolor  64 #> 65           5.6         2.9          3.6         1.3 versicolor  65 #> 66           6.7         3.1          4.4         1.4 versicolor  66 #> 67           5.6         3.0          4.5         1.5 versicolor  67 #> 68           5.8         2.7          4.1         1.0 versicolor  68 #> 69           6.2         2.2          4.5         1.5 versicolor  69 #> 70           5.6         2.5          3.9         1.1 versicolor  70 #> 71           5.9         3.2          4.8         1.8 versicolor  71 #> 72           6.1         2.8          4.0         1.3 versicolor  72 #> 73           6.3         2.5          4.9         1.5 versicolor  73 #> 74           6.1         2.8          4.7         1.2 versicolor  74 #> 75           6.4         2.9          4.3         1.3 versicolor  75 #> 76           6.6         3.0          4.4         1.4 versicolor  76 #> 77           6.8         2.8          4.8         1.4 versicolor  77 #> 78           6.7         3.0          5.0         1.7 versicolor  78 #> 79           6.0         2.9          4.5         1.5 versicolor  79 #> 80           5.7         2.6          3.5         1.0 versicolor  80 #> 81           5.5         2.4          3.8         1.1 versicolor  81 #> 82           5.5         2.4          3.7         1.0 versicolor  82 #> 83           5.8         2.7          3.9         1.2 versicolor  83 #> 84           6.0         2.7          5.1         1.6 versicolor  84 #> 85           5.4         3.0          4.5         1.5 versicolor  85 #> 86           6.0         3.4          4.5         1.6 versicolor  86 #> 87           6.7         3.1          4.7         1.5 versicolor  87 #> 88           6.3         2.3          4.4         1.3 versicolor  88 #> 89           5.6         3.0          4.1         1.3 versicolor  89 #> 90           5.5         2.5          4.0         1.3 versicolor  90 #> 91           5.5         2.6          4.4         1.2 versicolor  91 #> 92           6.1         3.0          4.6         1.4 versicolor  92 #> 93           5.8         2.6          4.0         1.2 versicolor  93 #> 94           5.0         2.3          3.3         1.0 versicolor  94 #> 95           5.6         2.7          4.2         1.3 versicolor  95 #> 96           5.7         3.0          4.2         1.2 versicolor  96 #> 97           5.7         2.9          4.2         1.3 versicolor  97 #> 98           6.2         2.9          4.3         1.3 versicolor  98 #> 99           5.1         2.5          3.0         1.1 versicolor  99 #> 100          5.7         2.8          4.1         1.3 versicolor 100 #> 101          6.3         3.3          6.0         2.5  virginica 101 #> 102          5.8         2.7          5.1         1.9  virginica 102 #> 103          7.1         3.0          5.9         2.1  virginica 103 #> 104          6.3         2.9          5.6         1.8  virginica 104 #> 105          6.5         3.0          5.8         2.2  virginica 105 #> 106          7.6         3.0          6.6         2.1  virginica 106 #> 107          4.9         2.5          4.5         1.7  virginica 107 #> 108          7.3         2.9          6.3         1.8  virginica 108 #> 109          6.7         2.5          5.8         1.8  virginica 109 #> 110          7.2         3.6          6.1         2.5  virginica 110 #> 111          6.5         3.2          5.1         2.0  virginica 111 #> 112          6.4         2.7          5.3         1.9  virginica 112 #> 113          6.8         3.0          5.5         2.1  virginica 113 #> 114          5.7         2.5          5.0         2.0  virginica 114 #> 115          5.8         2.8          5.1         2.4  virginica 115 #> 116          6.4         3.2          5.3         2.3  virginica 116 #> 117          6.5         3.0          5.5         1.8  virginica 117 #> 118          7.7         3.8          6.7         2.2  virginica 118 #> 119          7.7         2.6          6.9         2.3  virginica 119 #> 120          6.0         2.2          5.0         1.5  virginica 120 #> 121          6.9         3.2          5.7         2.3  virginica 121 #> 122          5.6         2.8          4.9         2.0  virginica 122 #> 123          7.7         2.8          6.7         2.0  virginica 123 #> 124          6.3         2.7          4.9         1.8  virginica 124 #> 125          6.7         3.3          5.7         2.1  virginica 125 #> 126          7.2         3.2          6.0         1.8  virginica 126 #> 127          6.2         2.8          4.8         1.8  virginica 127 #> 128          6.1         3.0          4.9         1.8  virginica 128 #> 129          6.4         2.8          5.6         2.1  virginica 129 #> 130          7.2         3.0          5.8         1.6  virginica 130 #> 131          7.4         2.8          6.1         1.9  virginica 131 #> 132          7.9         3.8          6.4         2.0  virginica 132 #> 133          6.4         2.8          5.6         2.2  virginica 133 #> 134          6.3         2.8          5.1         1.5  virginica 134 #> 135          6.1         2.6          5.6         1.4  virginica 135 #> 136          7.7         3.0          6.1         2.3  virginica 136 #> 137          6.3         3.4          5.6         2.4  virginica 137 #> 138          6.4         3.1          5.5         1.8  virginica 138 #> 139          6.0         3.0          4.8         1.8  virginica 139 #> 140          6.9         3.1          5.4         2.1  virginica 140 #> 141          6.7         3.1          5.6         2.4  virginica 141 #> 142          6.9         3.1          5.1         2.3  virginica 142 #> 143          5.8         2.7          5.1         1.9  virginica 143 #> 144          6.8         3.2          5.9         2.3  virginica 144 #> 145          6.7         3.3          5.7         2.5  virginica 145 #> 146          6.7         3.0          5.2         2.3  virginica 146 #> 147          6.3         2.5          5.0         1.9  virginica 147 #> 148          6.5         3.0          5.2         2.0  virginica 148 #> 149          6.2         3.4          5.4         2.3  virginica 149 #> 150          5.9         3.0          5.1         1.8  virginica 150 #>     sample_indicator #> 1                  0 #> 2                  0 #> 3                  0 #> 4                  0 #> 5                  0 #> 6                  0 #> 7                  0 #> 8                  1 #> 9                  0 #> 10                 1 #> 11                 0 #> 12                 0 #> 13                 0 #> 14                 0 #> 15                 0 #> 16                 0 #> 17                 0 #> 18                 0 #> 19                 0 #> 20                 0 #> 21                 0 #> 22                 0 #> 23                 0 #> 24                 1 #> 25                 0 #> 26                 0 #> 27                 0 #> 28                 0 #> 29                 1 #> 30                 0 #> 31                 0 #> 32                 0 #> 33                 0 #> 34                 0 #> 35                 0 #> 36                 0 #> 37                 0 #> 38                 0 #> 39                 0 #> 40                 0 #> 41                 0 #> 42                 0 #> 43                 0 #> 44                 1 #> 45                 0 #> 46                 0 #> 47                 0 #> 48                 0 #> 49                 0 #> 50                 0 #> 51                 0 #> 52                 0 #> 53                 0 #> 54                 0 #> 55                 0 #> 56                 0 #> 57                 0 #> 58                 0 #> 59                 1 #> 60                 0 #> 61                 0 #> 62                 0 #> 63                 0 #> 64                 0 #> 65                 0 #> 66                 0 #> 67                 0 #> 68                 0 #> 69                 0 #> 70                 0 #> 71                 0 #> 72                 0 #> 73                 1 #> 74                 0 #> 75                 0 #> 76                 0 #> 77                 0 #> 78                 0 #> 79                 0 #> 80                 0 #> 81                 0 #> 82                 0 #> 83                 0 #> 84                 1 #> 85                 0 #> 86                 0 #> 87                 0 #> 88                 0 #> 89                 0 #> 90                 0 #> 91                 0 #> 92                 1 #> 93                 0 #> 94                 0 #> 95                 0 #> 96                 0 #> 97                 0 #> 98                 1 #> 99                 0 #> 100                0 #> 101                0 #> 102                0 #> 103                0 #> 104                0 #> 105                0 #> 106                0 #> 107                1 #> 108                0 #> 109                0 #> 110                0 #> 111                0 #> 112                0 #> 113                0 #> 114                0 #> 115                0 #> 116                0 #> 117                0 #> 118                0 #> 119                1 #> 120                0 #> 121                0 #> 122                0 #> 123                0 #> 124                0 #> 125                0 #> 126                0 #> 127                0 #> 128                1 #> 129                0 #> 130                0 #> 131                0 #> 132                0 #> 133                1 #> 134                0 #> 135                1 #> 136                0 #> 137                0 #> 138                0 #> 139                0 #> 140                0 #> 141                0 #> 142                0 #> 143                0 #> 144                0 #> 145                0 #> 146                0 #> 147                0 #> 148                0 #> 149                0 #> 150                0  # To include probs as a formula sample_strata(   data = iris, strata = \"Species\", id = \"id\",   design_data = design, design_strata = \"strata\",   n_allocated = \"n_to_sample\", probs = ~n_to_sample/npop ) #>     Sepal.Length Sepal.Width Petal.Length Petal.Width    Species  id #> 1            5.1         3.5          1.4         0.2     setosa   1 #> 2            4.9         3.0          1.4         0.2     setosa   2 #> 3            4.7         3.2          1.3         0.2     setosa   3 #> 4            4.6         3.1          1.5         0.2     setosa   4 #> 5            5.0         3.6          1.4         0.2     setosa   5 #> 6            5.4         3.9          1.7         0.4     setosa   6 #> 7            4.6         3.4          1.4         0.3     setosa   7 #> 8            5.0         3.4          1.5         0.2     setosa   8 #> 9            4.4         2.9          1.4         0.2     setosa   9 #> 10           4.9         3.1          1.5         0.1     setosa  10 #> 11           5.4         3.7          1.5         0.2     setosa  11 #> 12           4.8         3.4          1.6         0.2     setosa  12 #> 13           4.8         3.0          1.4         0.1     setosa  13 #> 14           4.3         3.0          1.1         0.1     setosa  14 #> 15           5.8         4.0          1.2         0.2     setosa  15 #> 16           5.7         4.4          1.5         0.4     setosa  16 #> 17           5.4         3.9          1.3         0.4     setosa  17 #> 18           5.1         3.5          1.4         0.3     setosa  18 #> 19           5.7         3.8          1.7         0.3     setosa  19 #> 20           5.1         3.8          1.5         0.3     setosa  20 #> 21           5.4         3.4          1.7         0.2     setosa  21 #> 22           5.1         3.7          1.5         0.4     setosa  22 #> 23           4.6         3.6          1.0         0.2     setosa  23 #> 24           5.1         3.3          1.7         0.5     setosa  24 #> 25           4.8         3.4          1.9         0.2     setosa  25 #> 26           5.0         3.0          1.6         0.2     setosa  26 #> 27           5.0         3.4          1.6         0.4     setosa  27 #> 28           5.2         3.5          1.5         0.2     setosa  28 #> 29           5.2         3.4          1.4         0.2     setosa  29 #> 30           4.7         3.2          1.6         0.2     setosa  30 #> 31           4.8         3.1          1.6         0.2     setosa  31 #> 32           5.4         3.4          1.5         0.4     setosa  32 #> 33           5.2         4.1          1.5         0.1     setosa  33 #> 34           5.5         4.2          1.4         0.2     setosa  34 #> 35           4.9         3.1          1.5         0.2     setosa  35 #> 36           5.0         3.2          1.2         0.2     setosa  36 #> 37           5.5         3.5          1.3         0.2     setosa  37 #> 38           4.9         3.6          1.4         0.1     setosa  38 #> 39           4.4         3.0          1.3         0.2     setosa  39 #> 40           5.1         3.4          1.5         0.2     setosa  40 #> 41           5.0         3.5          1.3         0.3     setosa  41 #> 42           4.5         2.3          1.3         0.3     setosa  42 #> 43           4.4         3.2          1.3         0.2     setosa  43 #> 44           5.0         3.5          1.6         0.6     setosa  44 #> 45           5.1         3.8          1.9         0.4     setosa  45 #> 46           4.8         3.0          1.4         0.3     setosa  46 #> 47           5.1         3.8          1.6         0.2     setosa  47 #> 48           4.6         3.2          1.4         0.2     setosa  48 #> 49           5.3         3.7          1.5         0.2     setosa  49 #> 50           5.0         3.3          1.4         0.2     setosa  50 #> 51           7.0         3.2          4.7         1.4 versicolor  51 #> 52           6.4         3.2          4.5         1.5 versicolor  52 #> 53           6.9         3.1          4.9         1.5 versicolor  53 #> 54           5.5         2.3          4.0         1.3 versicolor  54 #> 55           6.5         2.8          4.6         1.5 versicolor  55 #> 56           5.7         2.8          4.5         1.3 versicolor  56 #> 57           6.3         3.3          4.7         1.6 versicolor  57 #> 58           4.9         2.4          3.3         1.0 versicolor  58 #> 59           6.6         2.9          4.6         1.3 versicolor  59 #> 60           5.2         2.7          3.9         1.4 versicolor  60 #> 61           5.0         2.0          3.5         1.0 versicolor  61 #> 62           5.9         3.0          4.2         1.5 versicolor  62 #> 63           6.0         2.2          4.0         1.0 versicolor  63 #> 64           6.1         2.9          4.7         1.4 versicolor  64 #> 65           5.6         2.9          3.6         1.3 versicolor  65 #> 66           6.7         3.1          4.4         1.4 versicolor  66 #> 67           5.6         3.0          4.5         1.5 versicolor  67 #> 68           5.8         2.7          4.1         1.0 versicolor  68 #> 69           6.2         2.2          4.5         1.5 versicolor  69 #> 70           5.6         2.5          3.9         1.1 versicolor  70 #> 71           5.9         3.2          4.8         1.8 versicolor  71 #> 72           6.1         2.8          4.0         1.3 versicolor  72 #> 73           6.3         2.5          4.9         1.5 versicolor  73 #> 74           6.1         2.8          4.7         1.2 versicolor  74 #> 75           6.4         2.9          4.3         1.3 versicolor  75 #> 76           6.6         3.0          4.4         1.4 versicolor  76 #> 77           6.8         2.8          4.8         1.4 versicolor  77 #> 78           6.7         3.0          5.0         1.7 versicolor  78 #> 79           6.0         2.9          4.5         1.5 versicolor  79 #> 80           5.7         2.6          3.5         1.0 versicolor  80 #> 81           5.5         2.4          3.8         1.1 versicolor  81 #> 82           5.5         2.4          3.7         1.0 versicolor  82 #> 83           5.8         2.7          3.9         1.2 versicolor  83 #> 84           6.0         2.7          5.1         1.6 versicolor  84 #> 85           5.4         3.0          4.5         1.5 versicolor  85 #> 86           6.0         3.4          4.5         1.6 versicolor  86 #> 87           6.7         3.1          4.7         1.5 versicolor  87 #> 88           6.3         2.3          4.4         1.3 versicolor  88 #> 89           5.6         3.0          4.1         1.3 versicolor  89 #> 90           5.5         2.5          4.0         1.3 versicolor  90 #> 91           5.5         2.6          4.4         1.2 versicolor  91 #> 92           6.1         3.0          4.6         1.4 versicolor  92 #> 93           5.8         2.6          4.0         1.2 versicolor  93 #> 94           5.0         2.3          3.3         1.0 versicolor  94 #> 95           5.6         2.7          4.2         1.3 versicolor  95 #> 96           5.7         3.0          4.2         1.2 versicolor  96 #> 97           5.7         2.9          4.2         1.3 versicolor  97 #> 98           6.2         2.9          4.3         1.3 versicolor  98 #> 99           5.1         2.5          3.0         1.1 versicolor  99 #> 100          5.7         2.8          4.1         1.3 versicolor 100 #> 101          6.3         3.3          6.0         2.5  virginica 101 #> 102          5.8         2.7          5.1         1.9  virginica 102 #> 103          7.1         3.0          5.9         2.1  virginica 103 #> 104          6.3         2.9          5.6         1.8  virginica 104 #> 105          6.5         3.0          5.8         2.2  virginica 105 #> 106          7.6         3.0          6.6         2.1  virginica 106 #> 107          4.9         2.5          4.5         1.7  virginica 107 #> 108          7.3         2.9          6.3         1.8  virginica 108 #> 109          6.7         2.5          5.8         1.8  virginica 109 #> 110          7.2         3.6          6.1         2.5  virginica 110 #> 111          6.5         3.2          5.1         2.0  virginica 111 #> 112          6.4         2.7          5.3         1.9  virginica 112 #> 113          6.8         3.0          5.5         2.1  virginica 113 #> 114          5.7         2.5          5.0         2.0  virginica 114 #> 115          5.8         2.8          5.1         2.4  virginica 115 #> 116          6.4         3.2          5.3         2.3  virginica 116 #> 117          6.5         3.0          5.5         1.8  virginica 117 #> 118          7.7         3.8          6.7         2.2  virginica 118 #> 119          7.7         2.6          6.9         2.3  virginica 119 #> 120          6.0         2.2          5.0         1.5  virginica 120 #> 121          6.9         3.2          5.7         2.3  virginica 121 #> 122          5.6         2.8          4.9         2.0  virginica 122 #> 123          7.7         2.8          6.7         2.0  virginica 123 #> 124          6.3         2.7          4.9         1.8  virginica 124 #> 125          6.7         3.3          5.7         2.1  virginica 125 #> 126          7.2         3.2          6.0         1.8  virginica 126 #> 127          6.2         2.8          4.8         1.8  virginica 127 #> 128          6.1         3.0          4.9         1.8  virginica 128 #> 129          6.4         2.8          5.6         2.1  virginica 129 #> 130          7.2         3.0          5.8         1.6  virginica 130 #> 131          7.4         2.8          6.1         1.9  virginica 131 #> 132          7.9         3.8          6.4         2.0  virginica 132 #> 133          6.4         2.8          5.6         2.2  virginica 133 #> 134          6.3         2.8          5.1         1.5  virginica 134 #> 135          6.1         2.6          5.6         1.4  virginica 135 #> 136          7.7         3.0          6.1         2.3  virginica 136 #> 137          6.3         3.4          5.6         2.4  virginica 137 #> 138          6.4         3.1          5.5         1.8  virginica 138 #> 139          6.0         3.0          4.8         1.8  virginica 139 #> 140          6.9         3.1          5.4         2.1  virginica 140 #> 141          6.7         3.1          5.6         2.4  virginica 141 #> 142          6.9         3.1          5.1         2.3  virginica 142 #> 143          5.8         2.7          5.1         1.9  virginica 143 #> 144          6.8         3.2          5.9         2.3  virginica 144 #> 145          6.7         3.3          5.7         2.5  virginica 145 #> 146          6.7         3.0          5.2         2.3  virginica 146 #> 147          6.3         2.5          5.0         1.9  virginica 147 #> 148          6.5         3.0          5.2         2.0  virginica 148 #> 149          6.2         3.4          5.4         2.3  virginica 149 #> 150          5.9         3.0          5.1         1.8  virginica 150 #>     sample_indicator sampling_prob #> 1                  0            NA #> 2                  0            NA #> 3                  0            NA #> 4                  0            NA #> 5                  0            NA #> 6                  0            NA #> 7                  1           0.1 #> 8                  0            NA #> 9                  0            NA #> 10                 1           0.1 #> 11                 0            NA #> 12                 0            NA #> 13                 0            NA #> 14                 0            NA #> 15                 0            NA #> 16                 0            NA #> 17                 0            NA #> 18                 0            NA #> 19                 0            NA #> 20                 0            NA #> 21                 0            NA #> 22                 0            NA #> 23                 0            NA #> 24                 0            NA #> 25                 0            NA #> 26                 0            NA #> 27                 0            NA #> 28                 0            NA #> 29                 0            NA #> 30                 1           0.1 #> 31                 0            NA #> 32                 1           0.1 #> 33                 0            NA #> 34                 0            NA #> 35                 0            NA #> 36                 0            NA #> 37                 0            NA #> 38                 0            NA #> 39                 0            NA #> 40                 0            NA #> 41                 0            NA #> 42                 0            NA #> 43                 0            NA #> 44                 0            NA #> 45                 1           0.1 #> 46                 0            NA #> 47                 0            NA #> 48                 0            NA #> 49                 0            NA #> 50                 0            NA #> 51                 1           0.1 #> 52                 1           0.1 #> 53                 0            NA #> 54                 1           0.1 #> 55                 0            NA #> 56                 0            NA #> 57                 0            NA #> 58                 0            NA #> 59                 0            NA #> 60                 0            NA #> 61                 0            NA #> 62                 0            NA #> 63                 0            NA #> 64                 0            NA #> 65                 1           0.1 #> 66                 0            NA #> 67                 1           0.1 #> 68                 0            NA #> 69                 0            NA #> 70                 0            NA #> 71                 0            NA #> 72                 0            NA #> 73                 0            NA #> 74                 0            NA #> 75                 0            NA #> 76                 0            NA #> 77                 0            NA #> 78                 0            NA #> 79                 0            NA #> 80                 0            NA #> 81                 0            NA #> 82                 0            NA #> 83                 0            NA #> 84                 0            NA #> 85                 0            NA #> 86                 0            NA #> 87                 0            NA #> 88                 0            NA #> 89                 0            NA #> 90                 0            NA #> 91                 0            NA #> 92                 0            NA #> 93                 0            NA #> 94                 0            NA #> 95                 0            NA #> 96                 0            NA #> 97                 0            NA #> 98                 0            NA #> 99                 0            NA #> 100                0            NA #> 101                0            NA #> 102                1           0.1 #> 103                1           0.1 #> 104                0            NA #> 105                0            NA #> 106                0            NA #> 107                0            NA #> 108                0            NA #> 109                0            NA #> 110                0            NA #> 111                0            NA #> 112                0            NA #> 113                0            NA #> 114                0            NA #> 115                0            NA #> 116                0            NA #> 117                0            NA #> 118                0            NA #> 119                0            NA #> 120                0            NA #> 121                0            NA #> 122                0            NA #> 123                0            NA #> 124                0            NA #> 125                0            NA #> 126                0            NA #> 127                0            NA #> 128                0            NA #> 129                0            NA #> 130                0            NA #> 131                0            NA #> 132                0            NA #> 133                0            NA #> 134                0            NA #> 135                0            NA #> 136                0            NA #> 137                1           0.1 #> 138                0            NA #> 139                0            NA #> 140                0            NA #> 141                1           0.1 #> 142                0            NA #> 143                1           0.1 #> 144                0            NA #> 145                0            NA #> 146                0            NA #> 147                0            NA #> 148                0            NA #> 149                0            NA #> 150                0            NA  # If some units had already been sampled iris$already_sampled <- rbinom(nrow(iris), 1, 0.25)  sample_strata(   data = iris, strata = \"Species\", id = \"id\",   already_sampled = \"already_sampled\",   design_data = design, design_strata = \"strata\",   n_allocated = \"n_to_sample\" ) #>     Sepal.Length Sepal.Width Petal.Length Petal.Width    Species  id #> 1            5.1         3.5          1.4         0.2     setosa   1 #> 2            4.9         3.0          1.4         0.2     setosa   2 #> 3            4.7         3.2          1.3         0.2     setosa   3 #> 4            4.6         3.1          1.5         0.2     setosa   4 #> 5            5.0         3.6          1.4         0.2     setosa   5 #> 6            5.4         3.9          1.7         0.4     setosa   6 #> 7            4.6         3.4          1.4         0.3     setosa   7 #> 8            5.0         3.4          1.5         0.2     setosa   8 #> 9            4.4         2.9          1.4         0.2     setosa   9 #> 10           4.9         3.1          1.5         0.1     setosa  10 #> 11           5.4         3.7          1.5         0.2     setosa  11 #> 12           4.8         3.4          1.6         0.2     setosa  12 #> 13           4.8         3.0          1.4         0.1     setosa  13 #> 14           4.3         3.0          1.1         0.1     setosa  14 #> 15           5.8         4.0          1.2         0.2     setosa  15 #> 16           5.7         4.4          1.5         0.4     setosa  16 #> 17           5.4         3.9          1.3         0.4     setosa  17 #> 18           5.1         3.5          1.4         0.3     setosa  18 #> 19           5.7         3.8          1.7         0.3     setosa  19 #> 20           5.1         3.8          1.5         0.3     setosa  20 #> 21           5.4         3.4          1.7         0.2     setosa  21 #> 22           5.1         3.7          1.5         0.4     setosa  22 #> 23           4.6         3.6          1.0         0.2     setosa  23 #> 24           5.1         3.3          1.7         0.5     setosa  24 #> 25           4.8         3.4          1.9         0.2     setosa  25 #> 26           5.0         3.0          1.6         0.2     setosa  26 #> 27           5.0         3.4          1.6         0.4     setosa  27 #> 28           5.2         3.5          1.5         0.2     setosa  28 #> 29           5.2         3.4          1.4         0.2     setosa  29 #> 30           4.7         3.2          1.6         0.2     setosa  30 #> 31           4.8         3.1          1.6         0.2     setosa  31 #> 32           5.4         3.4          1.5         0.4     setosa  32 #> 33           5.2         4.1          1.5         0.1     setosa  33 #> 34           5.5         4.2          1.4         0.2     setosa  34 #> 35           4.9         3.1          1.5         0.2     setosa  35 #> 36           5.0         3.2          1.2         0.2     setosa  36 #> 37           5.5         3.5          1.3         0.2     setosa  37 #> 38           4.9         3.6          1.4         0.1     setosa  38 #> 39           4.4         3.0          1.3         0.2     setosa  39 #> 40           5.1         3.4          1.5         0.2     setosa  40 #> 41           5.0         3.5          1.3         0.3     setosa  41 #> 42           4.5         2.3          1.3         0.3     setosa  42 #> 43           4.4         3.2          1.3         0.2     setosa  43 #> 44           5.0         3.5          1.6         0.6     setosa  44 #> 45           5.1         3.8          1.9         0.4     setosa  45 #> 46           4.8         3.0          1.4         0.3     setosa  46 #> 47           5.1         3.8          1.6         0.2     setosa  47 #> 48           4.6         3.2          1.4         0.2     setosa  48 #> 49           5.3         3.7          1.5         0.2     setosa  49 #> 50           5.0         3.3          1.4         0.2     setosa  50 #> 51           7.0         3.2          4.7         1.4 versicolor  51 #> 52           6.4         3.2          4.5         1.5 versicolor  52 #> 53           6.9         3.1          4.9         1.5 versicolor  53 #> 54           5.5         2.3          4.0         1.3 versicolor  54 #> 55           6.5         2.8          4.6         1.5 versicolor  55 #> 56           5.7         2.8          4.5         1.3 versicolor  56 #> 57           6.3         3.3          4.7         1.6 versicolor  57 #> 58           4.9         2.4          3.3         1.0 versicolor  58 #> 59           6.6         2.9          4.6         1.3 versicolor  59 #> 60           5.2         2.7          3.9         1.4 versicolor  60 #> 61           5.0         2.0          3.5         1.0 versicolor  61 #> 62           5.9         3.0          4.2         1.5 versicolor  62 #> 63           6.0         2.2          4.0         1.0 versicolor  63 #> 64           6.1         2.9          4.7         1.4 versicolor  64 #> 65           5.6         2.9          3.6         1.3 versicolor  65 #> 66           6.7         3.1          4.4         1.4 versicolor  66 #> 67           5.6         3.0          4.5         1.5 versicolor  67 #> 68           5.8         2.7          4.1         1.0 versicolor  68 #> 69           6.2         2.2          4.5         1.5 versicolor  69 #> 70           5.6         2.5          3.9         1.1 versicolor  70 #> 71           5.9         3.2          4.8         1.8 versicolor  71 #> 72           6.1         2.8          4.0         1.3 versicolor  72 #> 73           6.3         2.5          4.9         1.5 versicolor  73 #> 74           6.1         2.8          4.7         1.2 versicolor  74 #> 75           6.4         2.9          4.3         1.3 versicolor  75 #> 76           6.6         3.0          4.4         1.4 versicolor  76 #> 77           6.8         2.8          4.8         1.4 versicolor  77 #> 78           6.7         3.0          5.0         1.7 versicolor  78 #> 79           6.0         2.9          4.5         1.5 versicolor  79 #> 80           5.7         2.6          3.5         1.0 versicolor  80 #> 81           5.5         2.4          3.8         1.1 versicolor  81 #> 82           5.5         2.4          3.7         1.0 versicolor  82 #> 83           5.8         2.7          3.9         1.2 versicolor  83 #> 84           6.0         2.7          5.1         1.6 versicolor  84 #> 85           5.4         3.0          4.5         1.5 versicolor  85 #> 86           6.0         3.4          4.5         1.6 versicolor  86 #> 87           6.7         3.1          4.7         1.5 versicolor  87 #> 88           6.3         2.3          4.4         1.3 versicolor  88 #> 89           5.6         3.0          4.1         1.3 versicolor  89 #> 90           5.5         2.5          4.0         1.3 versicolor  90 #> 91           5.5         2.6          4.4         1.2 versicolor  91 #> 92           6.1         3.0          4.6         1.4 versicolor  92 #> 93           5.8         2.6          4.0         1.2 versicolor  93 #> 94           5.0         2.3          3.3         1.0 versicolor  94 #> 95           5.6         2.7          4.2         1.3 versicolor  95 #> 96           5.7         3.0          4.2         1.2 versicolor  96 #> 97           5.7         2.9          4.2         1.3 versicolor  97 #> 98           6.2         2.9          4.3         1.3 versicolor  98 #> 99           5.1         2.5          3.0         1.1 versicolor  99 #> 100          5.7         2.8          4.1         1.3 versicolor 100 #> 101          6.3         3.3          6.0         2.5  virginica 101 #> 102          5.8         2.7          5.1         1.9  virginica 102 #> 103          7.1         3.0          5.9         2.1  virginica 103 #> 104          6.3         2.9          5.6         1.8  virginica 104 #> 105          6.5         3.0          5.8         2.2  virginica 105 #> 106          7.6         3.0          6.6         2.1  virginica 106 #> 107          4.9         2.5          4.5         1.7  virginica 107 #> 108          7.3         2.9          6.3         1.8  virginica 108 #> 109          6.7         2.5          5.8         1.8  virginica 109 #> 110          7.2         3.6          6.1         2.5  virginica 110 #> 111          6.5         3.2          5.1         2.0  virginica 111 #> 112          6.4         2.7          5.3         1.9  virginica 112 #> 113          6.8         3.0          5.5         2.1  virginica 113 #> 114          5.7         2.5          5.0         2.0  virginica 114 #> 115          5.8         2.8          5.1         2.4  virginica 115 #> 116          6.4         3.2          5.3         2.3  virginica 116 #> 117          6.5         3.0          5.5         1.8  virginica 117 #> 118          7.7         3.8          6.7         2.2  virginica 118 #> 119          7.7         2.6          6.9         2.3  virginica 119 #> 120          6.0         2.2          5.0         1.5  virginica 120 #> 121          6.9         3.2          5.7         2.3  virginica 121 #> 122          5.6         2.8          4.9         2.0  virginica 122 #> 123          7.7         2.8          6.7         2.0  virginica 123 #> 124          6.3         2.7          4.9         1.8  virginica 124 #> 125          6.7         3.3          5.7         2.1  virginica 125 #> 126          7.2         3.2          6.0         1.8  virginica 126 #> 127          6.2         2.8          4.8         1.8  virginica 127 #> 128          6.1         3.0          4.9         1.8  virginica 128 #> 129          6.4         2.8          5.6         2.1  virginica 129 #> 130          7.2         3.0          5.8         1.6  virginica 130 #> 131          7.4         2.8          6.1         1.9  virginica 131 #> 132          7.9         3.8          6.4         2.0  virginica 132 #> 133          6.4         2.8          5.6         2.2  virginica 133 #> 134          6.3         2.8          5.1         1.5  virginica 134 #> 135          6.1         2.6          5.6         1.4  virginica 135 #> 136          7.7         3.0          6.1         2.3  virginica 136 #> 137          6.3         3.4          5.6         2.4  virginica 137 #> 138          6.4         3.1          5.5         1.8  virginica 138 #> 139          6.0         3.0          4.8         1.8  virginica 139 #> 140          6.9         3.1          5.4         2.1  virginica 140 #> 141          6.7         3.1          5.6         2.4  virginica 141 #> 142          6.9         3.1          5.1         2.3  virginica 142 #> 143          5.8         2.7          5.1         1.9  virginica 143 #> 144          6.8         3.2          5.9         2.3  virginica 144 #> 145          6.7         3.3          5.7         2.5  virginica 145 #> 146          6.7         3.0          5.2         2.3  virginica 146 #> 147          6.3         2.5          5.0         1.9  virginica 147 #> 148          6.5         3.0          5.2         2.0  virginica 148 #> 149          6.2         3.4          5.4         2.3  virginica 149 #> 150          5.9         3.0          5.1         1.8  virginica 150 #>     already_sampled sample_indicator #> 1                 0                0 #> 2                 0                0 #> 3                 0                0 #> 4                 0                0 #> 5                 1                0 #> 6                 0                0 #> 7                 1                0 #> 8                 1                0 #> 9                 0                0 #> 10                0                0 #> 11                0                0 #> 12                0                0 #> 13                1                0 #> 14                1                0 #> 15                0                0 #> 16                0                1 #> 17                0                0 #> 18                0                1 #> 19                0                0 #> 20                0                1 #> 21                0                0 #> 22                0                0 #> 23                0                1 #> 24                1                0 #> 25                1                0 #> 26                1                0 #> 27                0                0 #> 28                0                0 #> 29                1                0 #> 30                1                0 #> 31                0                0 #> 32                0                0 #> 33                1                0 #> 34                0                0 #> 35                1                0 #> 36                1                0 #> 37                0                0 #> 38                0                0 #> 39                1                0 #> 40                1                0 #> 41                0                1 #> 42                0                0 #> 43                1                0 #> 44                0                0 #> 45                0                0 #> 46                0                0 #> 47                0                0 #> 48                0                0 #> 49                0                0 #> 50                0                0 #> 51                0                0 #> 52                0                0 #> 53                0                0 #> 54                0                0 #> 55                0                0 #> 56                1                0 #> 57                0                0 #> 58                0                0 #> 59                0                0 #> 60                0                0 #> 61                0                0 #> 62                1                0 #> 63                0                0 #> 64                0                0 #> 65                1                0 #> 66                0                0 #> 67                0                0 #> 68                0                0 #> 69                0                1 #> 70                0                0 #> 71                0                1 #> 72                0                0 #> 73                0                0 #> 74                0                0 #> 75                0                0 #> 76                0                0 #> 77                1                0 #> 78                0                0 #> 79                0                0 #> 80                0                0 #> 81                1                0 #> 82                0                1 #> 83                0                0 #> 84                0                0 #> 85                0                0 #> 86                0                0 #> 87                0                0 #> 88                0                0 #> 89                0                0 #> 90                0                1 #> 91                0                0 #> 92                0                0 #> 93                0                0 #> 94                0                0 #> 95                0                0 #> 96                0                0 #> 97                0                0 #> 98                0                0 #> 99                0                0 #> 100               0                1 #> 101               0                0 #> 102               0                0 #> 103               0                0 #> 104               0                0 #> 105               0                0 #> 106               0                0 #> 107               0                1 #> 108               0                0 #> 109               0                0 #> 110               0                0 #> 111               0                0 #> 112               0                0 #> 113               0                1 #> 114               0                0 #> 115               0                0 #> 116               0                0 #> 117               1                0 #> 118               0                0 #> 119               0                0 #> 120               0                0 #> 121               0                0 #> 122               1                0 #> 123               0                0 #> 124               1                0 #> 125               0                0 #> 126               0                1 #> 127               0                1 #> 128               1                0 #> 129               0                0 #> 130               0                0 #> 131               0                0 #> 132               0                0 #> 133               0                0 #> 134               0                0 #> 135               1                0 #> 136               0                0 #> 137               0                0 #> 138               0                0 #> 139               0                1 #> 140               0                0 #> 141               0                0 #> 142               0                0 #> 143               1                0 #> 144               1                0 #> 145               0                0 #> 146               0                0 #> 147               0                0 #> 148               1                0 #> 149               0                0 #> 150               0                0"},{"path":"https://yangjasp.github.io/optimall/reference/set_mw-set.html","id":null,"dir":"Reference","previous_headings":"","what":"Write Slots of a Multiwave Object — set_mw<-","title":"Write Slots of a Multiwave Object — set_mw<-","text":"set_mw used assign values (write ) slots Multiwave class objects. used set values multiwave (mw) objects.","code":""},{"path":"https://yangjasp.github.io/optimall/reference/set_mw-set.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Write Slots of a Multiwave Object — set_mw<-","text":"","code":"set_mw(   x,   phase = 1,   wave = NA,   slot = c(\"data\", \"design\", \"metadata\", \"samples\", \"sampled_data\") ) <- value"},{"path":"https://yangjasp.github.io/optimall/reference/set_mw-set.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Write Slots of a Multiwave Object — set_mw<-","text":"x object class 'Multiwave' phase numeric value specifying phase accessed. access overall metadata, set phase = NA. Defaults 1. wave numeric value specifying wave accessed. Ta access phase metadata, set wave = NA. Defaults NA. slot character value specifying name slot accessed. Must one \"metadata\", \"design\", \"samples\", \"sampled_data\", \"data\". Defaults \"data\". See class documentation package vignettes information slots. value value assign specified slot","code":""},{"path":"https://yangjasp.github.io/optimall/reference/set_mw-set.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Write Slots of a Multiwave Object — set_mw<-","text":"","code":"# Intiate multiwave object MySurvey <- multiwave(phases = 2, waves = c(1, 3))  # To write overall metadata set_mw(MySurvey, phase = NA, slot = \"metadata\") <-  list(title = \"Maternal Weight Survey\")  # To write Phase 2 metadata set_mw(MySurvey, phase = 2, slot = \"metadata\") <-  list(strata = \"mystrata\", id = \"id\")"},{"path":"https://yangjasp.github.io/optimall/reference/shiny_server.html","id":null,"dir":"Reference","previous_headings":"","what":"Server logic for Interactive Shiny for Optimall. — shiny_server","title":"Server logic for Interactive Shiny for Optimall. — shiny_server","text":"Server logic Interactive Shiny Optimall.","code":""},{"path":"https://yangjasp.github.io/optimall/reference/shiny_server.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Server logic for Interactive Shiny for Optimall. — shiny_server","text":"","code":"shiny_server(input, output, session)"},{"path":"https://yangjasp.github.io/optimall/reference/shiny_server.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Server logic for Interactive Shiny for Optimall. — shiny_server","text":"input input Shiny server. output output Shiny server. session session Shiny server.","code":""},{"path":"https://yangjasp.github.io/optimall/reference/shiny_server.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Server logic for Interactive Shiny for Optimall. — shiny_server","text":"Defines server logic Shiny app can loaded optimall_shiny().","code":""},{"path":"https://yangjasp.github.io/optimall/reference/shiny_ui.html","id":null,"dir":"Reference","previous_headings":"","what":"UI for Shiny App for Splitting Strata with Optimum Allocation — shiny_ui","title":"UI for Shiny App for Splitting Strata with Optimum Allocation — shiny_ui","text":"UI Shiny App Splitting Strata Optimum Allocation","code":""},{"path":"https://yangjasp.github.io/optimall/reference/shiny_ui.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"UI for Shiny App for Splitting Strata with Optimum Allocation — shiny_ui","text":"","code":"shiny_ui()"},{"path":"https://yangjasp.github.io/optimall/reference/shiny_ui.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"UI for Shiny App for Splitting Strata with Optimum Allocation — shiny_ui","text":"Creates UI Shiny app loaded optimall_shiny.","code":""},{"path":"https://yangjasp.github.io/optimall/reference/split_strata.html","id":null,"dir":"Reference","previous_headings":"","what":"Split Strata — split_strata","title":"Split Strata — split_strata","text":"Splits pre-defined sampling strata based values continuous categorical variable.","code":""},{"path":"https://yangjasp.github.io/optimall/reference/split_strata.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Split Strata — split_strata","text":"","code":"split_strata(   data,   strata,   split = NULL,   split_var,   type = \"global quantile\",   split_at = 0.5,   trunc = NULL )"},{"path":"https://yangjasp.github.io/optimall/reference/split_strata.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Split Strata — split_strata","text":"data dataframe matrix one row sampling unit, one column specifying unit's current stratum, one column containing continuous categorical values define split, relevant columns. strata character string specifying name column defines unit's current strata. split name stratum strata split, exactly appear strata. Defaults NULL, indicates strata strata split. split_var character string specifying name column used define strata splits. type character string specifying function interpret split_at argument. Must one : \"global quantile\", default, splits strata quantiles specified split_at defined along entire, unfiltered split_var column. \"local quantile\" splits strata quantiles specified split_at defined along filtered split_var column includes units stratum split. \"value\" splits strata values specified split_at along split_var column. \"categorical\" splits strata two new strata, one contains unit split_var matches input split_at, second contains every unit. split_at percentile, value, name(s) split_var split . interpretation input depends type. \"quantile\" types, input must 0 1. Defaults 0.5 (median). \"categorical\" type, input vector values names split_var define new stratum. trunc numeric character value specifying name split_var truncated naming new strata. numeric, new strata name include first 'n' characters split_var name. character, specified string used name new strata instead split_var name. Defaults NULL, creates new strata name using entire name split_var column.","code":""},{"path":"https://yangjasp.github.io/optimall/reference/split_strata.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Split Strata — split_strata","text":"Returns input dataframe new column named 'new_strata' holds name stratum sample belongs split. column containing previous strata names retained given name \"old_strata\".","code":""},{"path":"https://yangjasp.github.io/optimall/reference/split_strata.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Split Strata — split_strata","text":"splits continuous variables, new strata defined left-open intervals. exception first interval, must include overall minimum value. names newly created strata split generated continuous value split_var column name range values defining stratum appended old strata name. categorical split, new strata names split_var column name appended 1/0 logical flag specifying whether unit split , appended old strata name. split_var column name long, user can specify value trunc prevent new strata names inconveniently long.","code":""},{"path":"https://yangjasp.github.io/optimall/reference/split_strata.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Split Strata — split_strata","text":"","code":"x <- split_strata(iris, \"Sepal.Length\",   strata = c(\"Species\"),   split = \"setosa\", split_var = \"Sepal.Width\",   split_at = c(0.5), type = \"global quantile\" )  # You can split at more than one quantile in one call. # The above call splits the \"setosa\" stratum into three of equal size x <- split_strata(iris, \"Sepal.Length\",   strata = c(\"Species\"),   split = \"setosa\", split_var = \"Sepal.Width\", split_at = c(0.33, 0.66),   type = \"local quantile\" )  # Manually select split values with type = \"value\" x <- split_strata(iris, \"Sepal.Length\",   strata = \"Species\",   split = \"setosa\", split_var = \"Sepal.Width\",   split_at = c(3.1, 3.8), type = \"value\" )  # Perform a categorical split. iris$strata <- rep(c(rep(1, times = 25), rep(0, times = 25)), times = 3) x <- split_strata(iris, \"Sepal.Length\",   strata = \"strata\",   split = NULL, split_var = \"Species\",   split_at = c(\"virginica\", \"versicolor\"), type = \"categorical\" ) # Splits each initial strata 1 and 2 into one stratum with \"virginia\" # and \"versicolor\" species and one stratum with all of the other species # not specified in the split_at argument."},{"path":"https://yangjasp.github.io/optimall/reference/summary-Multiwave-method.html","id":null,"dir":"Reference","previous_headings":"","what":"Method for summary for class Multiwave — summary,Multiwave-method","title":"Method for summary for class Multiwave — summary,Multiwave-method","text":"Method summary class Multiwave","code":""},{"path":"https://yangjasp.github.io/optimall/reference/summary-Multiwave-method.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Method for summary for class Multiwave — summary,Multiwave-method","text":"","code":"# S4 method for Multiwave summary(object)"},{"path":"https://yangjasp.github.io/optimall/reference/summary-Multiwave-method.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Method for summary for class Multiwave — summary,Multiwave-method","text":"object object class \"Multiwave\"","code":""},{"path":"https://yangjasp.github.io/optimall/reference/summary-Multiwave-method.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Method for summary for class Multiwave — summary,Multiwave-method","text":"Prints summary specified multiwave object console.","code":""},{"path":"https://yangjasp.github.io/optimall/news/index.html","id":"optimall-111","dir":"Changelog","previous_headings":"","what":"optimall 1.1.1","title":"optimall 1.1.1","text":"CRAN release: 2024-06-03","code":""},{"path":"https://yangjasp.github.io/optimall/news/index.html","id":"enhancements-1-1-1","dir":"Changelog","previous_headings":"","what":"Enhancements","title":"optimall 1.1.1","text":"Added new vignette describing estimation studies using multi-wave sampling using survey.","code":""},{"path":"https://yangjasp.github.io/optimall/news/index.html","id":"bug-fixes-1-1-1","dir":"Changelog","previous_headings":"","what":"Bug fixes","title":"optimall 1.1.1","text":"Revised tests pass OpenBLAS.","code":""},{"path":"https://yangjasp.github.io/optimall/news/index.html","id":"optimall-110","dir":"Changelog","previous_headings":"","what":"optimall 1.1.0","title":"optimall 1.1.0","text":"CRAN release: 2024-04-13","code":""},{"path":"https://yangjasp.github.io/optimall/news/index.html","id":"enhancements-1-1-0","dir":"Changelog","previous_headings":"","what":"Enhancements","title":"optimall 1.1.0","text":"number enhancements made Multiwave Object: set_mw() get_mw() easy access slots Variance parameters wave-specific sampling probabilities stored default. Added arguments apply_multiwave() sample_strata() storing sampling probabilities. Added arguments apply_multiwave(), sample_strata(), merge_samples() store sampling waves.","code":""},{"path":"https://yangjasp.github.io/optimall/news/index.html","id":"bug-fixes-1-1-0","dir":"Changelog","previous_headings":"","what":"Bug fixes","title":"optimall 1.1.0","text":"Updated function tests pass CRAN check M1Mac","code":""},{"path":"https://yangjasp.github.io/optimall/news/index.html","id":"optimall-015","dir":"Changelog","previous_headings":"","what":"optimall 0.1.5","title":"optimall 0.1.5","text":"CRAN release: 2024-02-15","code":""},{"path":"https://yangjasp.github.io/optimall/news/index.html","id":"bug-fixes-0-1-5","dir":"Changelog","previous_headings":"","what":"Bug fixes","title":"optimall 0.1.5","text":"Updated function tests pass CRAN check Windows","code":""},{"path":"https://yangjasp.github.io/optimall/news/index.html","id":"optimall-014","dir":"Changelog","previous_headings":"","what":"optimall 0.1.4","title":"optimall 0.1.4","text":"CRAN release: 2024-01-12","code":""},{"path":"https://yangjasp.github.io/optimall/news/index.html","id":"enhancements-0-1-4","dir":"Changelog","previous_headings":"","what":"Enhancements","title":"optimall 0.1.4","text":"allocate_wave() now defaults providing detailed summary allocation","code":""},{"path":"https://yangjasp.github.io/optimall/news/index.html","id":"bug-fixes-0-1-4","dir":"Changelog","previous_headings":"","what":"Bug fixes","title":"optimall 0.1.4","text":"Increased phantomJS timeout time optimall_shiny() test pass CRAN check","code":""},{"path":"https://yangjasp.github.io/optimall/news/index.html","id":"optimall-013","dir":"Changelog","previous_headings":"","what":"optimall 0.1.3","title":"optimall 0.1.3","text":"CRAN release: 2023-09-06","code":""},{"path":"https://yangjasp.github.io/optimall/news/index.html","id":"enhancements-0-1-3","dir":"Changelog","previous_headings":"","what":"Enhancements","title":"optimall 0.1.3","text":"Updated documentation get_data() Added options allocation method allocate_wave()","code":""},{"path":"https://yangjasp.github.io/optimall/news/index.html","id":"bug-fixes-0-1-3","dir":"Changelog","previous_headings":"","what":"Bug fixes","title":"optimall 0.1.3","text":"Fixed input binding error testing shiny windows pass CRAN check","code":""},{"path":"https://yangjasp.github.io/optimall/news/index.html","id":"optimall-012","dir":"Changelog","previous_headings":"","what":"optimall 0.1.2","title":"optimall 0.1.2","text":"CRAN release: 2022-11-09","code":""},{"path":"https://yangjasp.github.io/optimall/news/index.html","id":"bug-fixes-0-1-2","dir":"Changelog","previous_headings":"","what":"Bug fixes","title":"optimall 0.1.2","text":"Updated function tests pass CRAN check M1mac","code":""},{"path":"https://yangjasp.github.io/optimall/news/index.html","id":"optimall-011","dir":"Changelog","previous_headings":"","what":"optimall 0.1.1","title":"optimall 0.1.1","text":"CRAN release: 2022-02-09","code":""},{"path":"https://yangjasp.github.io/optimall/news/index.html","id":"bug-fixes-0-1-1","dir":"Changelog","previous_headings":"","what":"Bug fixes","title":"optimall 0.1.1","text":"Fixed typos documentation Updated function tests pass CRAN check regarding .equal.numeric()","code":""},{"path":"https://yangjasp.github.io/optimall/news/index.html","id":"optimall-010","dir":"Changelog","previous_headings":"","what":"optimall 0.1.0","title":"optimall 0.1.0","text":"CRAN release: 2021-07-21 Initial release","code":""}]
